<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/818CD6C9-61EE-41F2-9F37-0C7A8F43E25D"><gtr:id>818CD6C9-61EE-41F2-9F37-0C7A8F43E25D</gtr:id><gtr:name>University of Birmingham</gtr:name><gtr:department>School of Computer Science</gtr:department><gtr:address><gtr:line1>Edgbaston Park Road</gtr:line1><gtr:line2>Edgbaston</gtr:line2><gtr:postCode>B15 2TT</gtr:postCode><gtr:region>West Midlands</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/818CD6C9-61EE-41F2-9F37-0C7A8F43E25D"><gtr:id>818CD6C9-61EE-41F2-9F37-0C7A8F43E25D</gtr:id><gtr:name>University of Birmingham</gtr:name><gtr:address><gtr:line1>Edgbaston Park Road</gtr:line1><gtr:line2>Edgbaston</gtr:line2><gtr:postCode>B15 2TT</gtr:postCode><gtr:region>West Midlands</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/D62539FF-02CC-4DE1-B96E-F004C58ACFC7"><gtr:id>D62539FF-02CC-4DE1-B96E-F004C58ACFC7</gtr:id><gtr:firstName>Neel</gtr:firstName><gtr:surname>Krishnaswami</gtr:surname><gtr:roles><gtr:role><gtr:name>CO_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/5F5AA040-40C1-4D09-A4CF-9D5410E1F8FD"><gtr:id>5F5AA040-40C1-4D09-A4CF-9D5410E1F8FD</gtr:id><gtr:firstName>Paul</gtr:firstName><gtr:otherNames>Blain</gtr:otherNames><gtr:surname>Levy</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FN023757%2F1"><gtr:id>7AB9BC56-25EB-405A-A0A7-584046FB2E0B</gtr:id><gtr:title>Recursion, guarded recursion and computational effects</gtr:title><gtr:status>Active</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/N023757/1</gtr:grantReference><gtr:abstractText>This three-part project develops new ways of reasoning about computer programs and new kinds of programming language.

Recursion

Programs frequently delegate tasks to other programs, but there are some programs that take this a step further: they delegate tasks to themselves. This style of programming is called &amp;quot;recursion&amp;quot;. When it is done well, it is a powerful technique, because it focuses the programmer's attention on the key question of how to break down their hard problem into easier parts. And the parts get easier and easier until they are completely straightforward and no further delegation is required. But when recursion is done badly, the program just keeps delegating endlessly and the system hangs. 

Therefore, we need to be able to reason correctly about programs that use recursion, to make sure this kind of problem does not happen. One particularly powerful way of reasoning about programs is called &amp;quot;denotational semantics&amp;quot;, where every piece of code corresponds to some mathematical entity, and we can reason directly about those entities. But developing reasoning methods, and denotational semantics in particular, depends on what language the programs are written in. So it is important to develop forms of programming language that support reasoning about recursive programs. 

The first part of the project investigates recursion in a fundamental theoretical language called &amp;quot;call-by-push-value&amp;quot;, which has been shown to provide the building blocks from which many kinds of programs are made. At present, denotational semantics for recursive programs in this setting are not known, which means that it is impossible to give a well-defined meaning to parts of programs. We shall rectify this by developing a suitable denotational semantics. The degree of success of this stage will directly and greatly simplify the development of the later two stages of this project.

Guarded recursion

Some programs employ recursion in a special way: every time the program delegates a task to itself, it prints a message. This is called &amp;quot;guarded recursion&amp;quot;. It eliminates the risk of the program hanging, which is an undesirable behaviour, and instead the program continually interacts with the user. The messages can be used to track the progress of the program's execution, and for this reason guarded recursion is easier to reason about.

The second and main part of the project investigates guarded recursion, with the aim of developing a language that provides the building blocks of programs using guarded recursion. It will do this by collecting various denotational semantics of existing languages and then looking for patterns.

For the third part, we describe a program using general recursion into a program using guarded recursion. To do so, we attach a &amp;quot;print message&amp;quot; instruction each time the program delegates a task. That makes the recursion guarded, and easier to reason about. Once we have completed our reasoning, we hide the messages, making sure that the real user of the program cannot see them, so from their viewpoint the recursion is not guarded. We use this idea to give denotational semantics to a language with general recursion, in a setting currently considered challenging. This will illusrate the importance of guarded recursion for arbitrary recursive programs.</gtr:abstractText><gtr:potentialImpactText>The research in this project is connected to several important concerns for the development of software:

- how to reason about programs to ensure that they meet appropriate
 specifications, do not contain bugs and do not hang;

- how to divide a programming task between several programmers in a way that enables them to work separately, so that the coding scales with the size of the system;

- how to compile and optimize programs in a way that preserves the meaning and does not introduce bugs;

- above all, how to design and extend programming languages so as to facilitate the previous objectives.

While the project is theoretical and so its immmediate impact will be on other academic researchers, it contributes to the development of better solutions to these problems, which will benefit the software industry by enabling code to be developed faster and more correctly. In turn this will benefit society, which suffers from non-working software due to incorrect code, and from a lack of suitable software due to the slow rate of development. 

Rather than concentrating on a specific programming task or problem, we examine general structures that arise in different kinds of program. Just as cells are the building blocks of living organisms, and molecules and atoms are the building blocks of matter, it has been shown using mathematical models that there are also building blocks of programs. By recognizing these and knowing their properties, and analyzing other kinds of programs in a similar way, we will be better able to produce correct code.

The main part of this work will, if successful, give a new way of writing programs that are intended to interact with users repeatedly without hanging. At present this can be done only in very restricted ways, but by extracting the building blocks of those programs we hope to construct a flexible language that will make such programs easier to write.</gtr:potentialImpactText><gtr:fund><gtr:end>2019-12-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2016-07-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>361843</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>In most programming languages, each piece of data has a type, such as the type of numbers or colours. A key question is when two types are essentially the same. I showed that the traditional answer doesn't work in general, whereas a new answer, based on the legitimacy of replacing one type by the other in any context, works in several different kinds of programming language.</gtr:description><gtr:exploitationPathways>It might be studied for a wider variety of programming languages. It might enable software libraries written for one type to be applied to data of another type that is essentially the same in this new sense.</gtr:exploitationPathways><gtr:id>B125CB7C-B405-4E5E-8D77-07F1BEBB8B6E</gtr:id><gtr:outcomeId>58c9f53eb1f1c5.63617128</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors><gtr:url>http://www.cs.bham.ac.uk/~pbl/papers/contextiso.pdf</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>1E2AD3C8-DC94-4B34-BBE7-EAA9B50DCBBC</gtr:id><gtr:title>Effectful applicative bisimilarity: Monads, relators, and Howe's method</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c40f0d205e2adb2b84a9b3725f62016f"><gtr:id>c40f0d205e2adb2b84a9b3725f62016f</gtr:id><gtr:otherNames>Lago U</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5aa70d96dde636.96151739</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>999D6EE6-0926-4C55-B137-C5DAACE5741F</gtr:id><gtr:title>A monad for full ground reference cells</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ef0f520275ae56829fe2cc0c22e92e37"><gtr:id>ef0f520275ae56829fe2cc0c22e92e37</gtr:id><gtr:otherNames>Kammar O</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5aa70d08689339.40483157</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>02598C00-0FCA-4A98-A3B4-104C79BD0F37</gtr:id><gtr:title>Iteration and Labelled Iteration</gtr:title><gtr:parentPublicationTitle>Electronic Notes in Theoretical Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/30901fbe08790dd8e13869dc71f519c2"><gtr:id>30901fbe08790dd8e13869dc71f519c2</gtr:id><gtr:otherNames>Geron B</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>5aa70e0fcd0a19.76797060</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/N023757/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>