<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/7872603A-CCF5-4E49-A79D-619079BF7A4A"><gtr:id>7872603A-CCF5-4E49-A79D-619079BF7A4A</gtr:id><gtr:firstName>HONGSEOK</gtr:firstName><gtr:surname>YANG</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FE053041%2F2"><gtr:id>88F63C31-020B-4CA0-819B-AF048DD8DF14</gtr:id><gtr:title>Scalable Program Analysis for Software Verification</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Fellowship</gtr:grantCategory><gtr:grantReference>EP/E053041/2</gtr:grantReference><gtr:abstractText>Recent years have seen a renaissance in automatic program verification, based on advances in program analysis (abstract interpretation).Tools such as Microsoft's Static Driver Verifiercan automatically verify certain lightweight properties (e.g., protocol properties)of interfaces between program components.There is, though, a fundamental problem:Scalable methods are lacking.Current tools are based on a closed world assumption,where a complete program is available,and they work over a system's entire global state.This lack of modularity impedes scalability, and wider applicability. This research proposes an attack on the scalability problem.Our thesis is that progress in three directions, localization,isolation and generalization, can lead to much more scalable analyses.The idea of the first two of these isto reduce the cost for analyzing each component once,while the third aims to ensure thatone analysis result of a program component can be reused in manydifferent contexts. We will develop a general framework and concreteinstances of analyses that achieve these three goals.We will test our ideas by developing prototype toolsthat we will apply to widely-used open-source infrastructure software,such as network software and operating system components.Scalability is the core problem in the automatic verification of software.Success on the problems in this research would have a majorimpact on the use of automatic techniques for theanalysis and verification of significant, real-world code.</gtr:abstractText><gtr:fund><gtr:end>2012-09-30</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2011-05-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>120682</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>The methods that I developed with colleagues are now routinely used in automatic verification tools for verifying heap-related properties nowadays. Also, based on this method, I and colleagues developed a tool called Abductor for automatically verifying the absence of memory-related errors from C programs. This tool has been commercialised, and led to a start-up company, Monoidics, which was later acquired by Facebook. The current evolution of the tool is now a part of a tool-chain in Facebook. For the date in the box below, I put the acquisition date of Monoidics by Facebook.</gtr:description><gtr:firstYearOfImpact>2013</gtr:firstYearOfImpact><gtr:id>DB325BBB-D586-463E-B24F-D437597F35A6</gtr:id><gtr:impactTypes><gtr:impactType>Economic</gtr:impactType></gtr:impactTypes><gtr:outcomeId>545f79aab2ba66.54803116</gtr:outcomeId><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>With colleagues, I developed new effective methods for automatically proving that computer software does not have memory-related errors. The methods have been implemented in tools, called SpaceInvader and Abductor, which can automatically prove the absence of memory-related errors for C programs. The latter tool, Abductor, became commercialised, and led to the start-up company, Monoidics, which was later acquired by Facebook.</gtr:description><gtr:exploitationPathways>The methods that I developed with colleagues are now routinely used in automatic verification tools for verifying heap-related properties nowadays. Also, based on this method, I and colleagues developed a tool called Abductor for automatically verifying the absence of memory-related errors from C programs. This tool has been commercialised, and led to a start-up company, Monoidics, which was later acquired by Facebook. The current evolution of the tool is now a part of a tool-chain in Facebook.</gtr:exploitationPathways><gtr:id>78D0062B-9672-415A-B5F9-9A40D7914F4F</gtr:id><gtr:outcomeId>545f7917827720.71688891</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>8527DC2B-0011-49C9-899D-8AF54C4E5876</gtr:id><gtr:title>A divide-and-conquer approach for analysing overlaid data structures</gtr:title><gtr:parentPublicationTitle>Formal Methods in System Design</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/23adaa9e5b08bfb8c63d49eb2dbd8079"><gtr:id>23adaa9e5b08bfb8c63d49eb2dbd8079</gtr:id><gtr:otherNames>Lee O</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>544d6b6acbcb79.53638865</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>EBBCE61F-80BA-4E20-8E9A-741226324C3F</gtr:id><gtr:title>Linearizability with Ownership Transfer</gtr:title><gtr:parentPublicationTitle>Logical Methods in Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/44c63dbeb0938754db60bb8fe1c6db78"><gtr:id>44c63dbeb0938754db60bb8fe1c6db78</gtr:id><gtr:otherNames>Gotsman A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>544d68d6110445.79071409</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>E2BF13F1-890B-4377-B03A-DB5F807111CD</gtr:id><gtr:title>Two for the Price of One: Lifting Separation Logic Assertions</gtr:title><gtr:parentPublicationTitle>Logical Methods in Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/0f48b34e8537611da2bd22fa50721bf6"><gtr:id>0f48b34e8537611da2bd22fa50721bf6</gtr:id><gtr:otherNames>Thamsborg J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>544d6ab7350aa3.27529763</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>0DCF1699-4E50-4115-A51B-9621DC0654E3</gtr:id><gtr:title>Step-indexed kripke models over recursive worlds</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/6e1a31bf649397f21bc751573843a912"><gtr:id>6e1a31bf649397f21bc751573843a912</gtr:id><gtr:otherNames>Birkedal L</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>545002f8274584.93943454</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>7BBAF6BE-3FC8-4436-8D30-C0E93137CBE8</gtr:id><gtr:title>Modular verification of preemptive OS kernels</gtr:title><gtr:parentPublicationTitle>Journal of Functional Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/d673dc01aab117155b1e464909639e92"><gtr:id>d673dc01aab117155b1e464909639e92</gtr:id><gtr:otherNames>GOTSMAN A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>544d64e9b575e0.58688773</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>8807117D-CBBD-4CBC-A5AF-4D60504BCF04</gtr:id><gtr:title>Nested Hoare Triples and Frame Rules for Higher-order Store</gtr:title><gtr:parentPublicationTitle>Logical Methods in Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7d609db7ba4e4f926d59f67fd7d55eca"><gtr:id>7d609db7ba4e4f926d59f67fd7d55eca</gtr:id><gtr:otherNames>Schwinghammer J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>5450002460ad72.17379090</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>B8DA09FB-62CE-450A-A31D-53B11D69EBF0</gtr:id><gtr:title>Compositional Shape Analysis by Means of Bi-Abduction</gtr:title><gtr:parentPublicationTitle>Journal of the ACM</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/f16d98c6c088408dcf7cd02f629624f7"><gtr:id>f16d98c6c088408dcf7cd02f629624f7</gtr:id><gtr:otherNames>Calcagno C</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>545000bf065102.75071640</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/E053041/2</gtr:identifier></gtr:identifiers><gtr:projectHierarchy><gtr:parents><gtr:parent><gtr:id>933A7DA5-B625-427B-98A3-27997D3550D5</gtr:id><gtr:grantRef>EP/E053041/1</gtr:grantRef><gtr:amount>437665.72</gtr:amount><gtr:start>2007-10-01</gtr:start><gtr:end>2011-05-01</gtr:end><gtr:children><gtr:child rel="Transfer"><gtr:id>88F63C31-020B-4CA0-819B-AF048DD8DF14</gtr:id><gtr:grantRef>EP/E053041/2</gtr:grantRef><gtr:amount>120682.76</gtr:amount><gtr:start>2011-05-01</gtr:start><gtr:end>2012-09-30</gtr:end><gtr:children/></gtr:child></gtr:children></gtr:parent></gtr:parents></gtr:projectHierarchy><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>50</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>50</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>