<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations><gtr:collaborator url="http://gtr.ukri.org:80/organisation/39D10893-E08C-494F-A9C0-FFD70B1BDF35"><gtr:id>39D10893-E08C-494F-A9C0-FFD70B1BDF35</gtr:id><gtr:name>Oracle Corporation</gtr:name><gtr:address><gtr:line1>New England Development Center</gtr:line1><gtr:line2>One Oracle Drive</gtr:line2><gtr:line3>Nashua</gtr:line3><gtr:region>Outside UK</gtr:region><gtr:country>United States</gtr:country></gtr:address></gtr:collaborator></gtr:collaborations><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/318B5D98-4CB4-4B10-A876-08FC93071A56"><gtr:id>318B5D98-4CB4-4B10-A876-08FC93071A56</gtr:id><gtr:name>King's College London</gtr:name><gtr:department>Informatics</gtr:department><gtr:address><gtr:line1>Capital House</gtr:line1><gtr:line2>2nd Floor, Guys Campus</gtr:line2><gtr:line3>42 Weston Street</gtr:line3><gtr:line4>London</gtr:line4><gtr:postCode>SE1 3QD</gtr:postCode><gtr:region>London</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/318B5D98-4CB4-4B10-A876-08FC93071A56"><gtr:id>318B5D98-4CB4-4B10-A876-08FC93071A56</gtr:id><gtr:name>King's College London</gtr:name><gtr:address><gtr:line1>Capital House</gtr:line1><gtr:line2>2nd Floor, Guys Campus</gtr:line2><gtr:line3>42 Weston Street</gtr:line3><gtr:line4>London</gtr:line4><gtr:postCode>SE1 3QD</gtr:postCode><gtr:region>London</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>FELLOW</gtr:name></gtr:role><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/39D10893-E08C-494F-A9C0-FFD70B1BDF35"><gtr:id>39D10893-E08C-494F-A9C0-FFD70B1BDF35</gtr:id><gtr:name>Oracle Corporation</gtr:name><gtr:address><gtr:line1>New England Development Center</gtr:line1><gtr:line2>One Oracle Drive</gtr:line2><gtr:line3>Nashua</gtr:line3><gtr:region>Outside UK</gtr:region><gtr:country>United States</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>COLLABORATOR</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/C5503F80-B677-44FC-9B00-58EE297A43D9"><gtr:id>C5503F80-B677-44FC-9B00-58EE297A43D9</gtr:id><gtr:name>Intentional Software</gtr:name><gtr:address><gtr:line1>2821 Northup Way, Suite 250</gtr:line1><gtr:region>Outside UK</gtr:region></gtr:address><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/50A1DE17-1630-406A-BAAA-5ADFD19C5E3B"><gtr:id>50A1DE17-1630-406A-BAAA-5ADFD19C5E3B</gtr:id><gtr:firstName>Laurence</gtr:firstName><gtr:surname>Tratt</gtr:surname><gtr:orcidId>0000-0002-5258-3805</gtr:orcidId><gtr:roles><gtr:role><gtr:name>FELLOW</gtr:name></gtr:role><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FL02344X%2F1"><gtr:id>93CDE97A-A291-45F1-817D-53B18A815A9F</gtr:id><gtr:title>LECTURE: LanguagE ComposiTion UnifiEd</gtr:title><gtr:status>Active</gtr:status><gtr:grantCategory>Fellowship</gtr:grantCategory><gtr:grantReference>EP/L02344X/1</gtr:grantReference><gtr:abstractText>General purpose programming languages are the basis of virtually all current software systems. However, most large problems do not naturally decompose onto the strengths of any single programming language. Consider a government department processing economic data. Its data collection team might prefer to use Python; its data analysis team R; and its front-end team Java. However, since functionality is intermingled -- the front-end may need to both process and analyse data, for example -- it is currently impractical to use different languages in such a way. Instead, such users are typically forced to pick a single language, even though it is inappropriate for much of what they need.

Language composition is one answer to this long-standing problem: it aims to allow users to mix languages (programming languages and / or domain specific languages) in a fine-grained manner, so that each part of a problem can be expressed using the language most suited to it. However, existing language composition approaches tend either to be safe but limited in expressivity (e.g. Converge) or flexible but unsafe (e.g. MetaBorg/Stratego). This unpalatable choice is in no small part caused by the division of programming into three main phases: editing, compilation, and execution. Each phase has its own tool(s), forcing a language's semantics to be duplicated over multiple systems. Various problems result: discrepancies, or approximations, of language semantics amongst tools cause subtle bugs; information loss between tools stymies debugging; and encodings lead to poor performance.

The Lecture fellowship hypothesises that language composition needs a unified tool environment, equivalent to programming language IDEs. This will free language composition from the many practical burdens imposed by spreading language composition over multiple, distinct tools. We call the tooling required a &amp;quot;foundry&amp;quot;, an environment for new languages to be &amp;quot;cast&amp;quot; by composing languages together; the resultant languages can then be used to write programs. Foundries will provide a single environment to end-users that will allow them to compose languages, write programs in the result, compile them into a suitable end target, execute, and debug them. Foundries can therefore be thought of as a combination of a customisable editor and compiler, providing a single environment to end-users that will allow them to compose languages, write programs in the result, compile them into a suitable end target, execute, and debug them. Ultimately, we envisage end-users choosing amongst different foundries in the same way that they can choose amongst multiple IDEs. Once a foundry has been chosen and downloaded, the user will then select between already implemented language components to create their own composed language. They will then edit programs in as natural a fashion as they can in current IDEs. 

Tratt's existing language composition research -- language boxes make editing composed programs a reality; and VM composition makes running composed programs feasible -- provides pillars upon which to build, but many areas remain untackled and it is to those that Lecture addresses itself. Languages will need to be defined as a series of sub-components (e.g. syntax, implementation, type definitions). Intra-language mappings will relate syntax to implementations. Inter-language mappings will allow different languages to interact statically (e.g. to build type checkers) and dynamically (e.g. to exchange run-time data). Tooling will need to be developed to express each of these and to present the result to users in a comprehensible fashion. Alongside these are important design issues: what are sensible granularity levels for language components? how can foundries be best structured? etc.</gtr:abstractText><gtr:potentialImpactText>By improving the languages we have at our disposal to express software, Lecture will benefit several different groups. We identify two in particular.

Language designers are the initial target for Lecture's output. Although programming language design can appear to be simple, it is a tricky task, consisting of many small, subtly interlocking, decisions: seemingly inconsequential decisions taken early on often turn out later to be crucial in determining adoption. Since programming languages are currently designed and implemented almost entirely from scratch, creating a new language is a lengthy and risky enterprise, where small mistakes can ruin years of hard work. Furthermore, even if every decision taken is a good one, designing a language which people wish to use is difficult: many good language design ideas have faded into obscurity because the languages they were a part of were considered insufficiently mature to be worth investigating.

Lecture will therefore give language designers and implementers new means to experiment with languages, and to reduce their production costs significantly. By breaking languages into components, Lecture will increase the likelihood of reuse and reduce the chances of well understood problems creeping into language design. Lecture may even remove the need for general purpose language design where that is instigated purely to add, remove, or alter a single aspect of a previous language.

The second target for Lecture is software developers. If Lecture is able to realise the potential of language composition, it will open up entirely new avenues for software development and change the way software is developed. Different developers working on a single system will be able to improve their efficiency by using the languages best suited to their purposes. In the longer term, language composition may empower experts in non-computing domains to write parts of software, removing one of the most painful bottlenecks in software development. Health-care professionals, for example, may be able to specify relevant software behaviour directly instead of mediating through developers. Fine-grained language composition will also open up new possibilities for migrating \1 software gradually to newer languages, without the `big bang' that often hinders such efforts currently.

To realise Lecture's impact, we will focus on community appearances, publicly available and accessibly written articles, and uptake by respected organisations. We will also hold two workshops: the first focused on researchers in relevant areas including language designers; the second on potential early adopters.</gtr:potentialImpactText><gtr:fund><gtr:end>2019-07-19</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2014-07-20</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>953404</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs><gtr:collaborationOutput><gtr:collaboratingOrganisation>Oracle Corporation</gtr:collaboratingOrganisation><gtr:country>United Kingdom of Great Britain &amp; Northern Ireland (UK)</gtr:country><gtr:department>Oracle Corporation UK Ltd</gtr:department><gtr:description>Visualizing Cross-Language Execution</gtr:description><gtr:id>4AAAEB13-E2E7-4D60-ABBC-91FB4A84D454</gtr:id><gtr:impact>Not currently applicable.</gtr:impact><gtr:outcomeId>58a47f3cd51dc8.86102679-1</gtr:outcomeId><gtr:partnerContribution>We have regular meetings with two members of Oracle Labs; they have provided ideas, and data to validate our ideas.</gtr:partnerContribution><gtr:piContribution>I am the PI on this project investigating the visualisation of program execution in the face of language composition.</gtr:piContribution><gtr:sector>Private</gtr:sector><gtr:start>2016-01-01</gtr:start></gtr:collaborationOutput><gtr:collaborationOutput><gtr:collaboratingOrganisation>Oracle Corporation</gtr:collaboratingOrganisation><gtr:country>United States of America</gtr:country><gtr:department>Oracle EMEA</gtr:department><gtr:description>Lexical Cross-Language Interoperability</gtr:description><gtr:id>1F2A0ABF-157C-4FB2-97B2-83C3F9BD3F7C</gtr:id><gtr:impact>Ongoing.</gtr:impact><gtr:outcomeId>56ccadb7645796.08546756-1</gtr:outcomeId><gtr:partnerContribution>We have regular meetings with Oracle Labs (mostly telecons, but also in-person meetings) where we share expertise and experiences in both directions.</gtr:partnerContribution><gtr:piContribution>This funding is supporting 1 Research Associate for 1 year investigating how different languages used in composed programs interoperate, considering such issues as debugging and profiling.</gtr:piContribution><gtr:sector>Private</gtr:sector><gtr:start>2015-01-01</gtr:start></gtr:collaborationOutput></gtr:collaborationOutputs><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>PyHyp is the first large-scale language composition of two real-world languages: in this case PHP and Python. It consists of a fast virtual machine to execute PyHyp programs and special editor support via the Eco tool to make writing composed programs plausible.</gtr:description><gtr:id>FD0F7327-94CE-415B-B7CB-847FAFF78D67</gtr:id><gtr:impact>Too early to state.</gtr:impact><gtr:outcomeId>58a48a17431b63.32603891</gtr:outcomeId><gtr:title>PyHyp</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/pubs/files/pyhyp/</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>SQPyte takes the widely used SQLite database and converts part of it into a fast meta-tracing virtual machine. When called regularly from a programming language, SQPyte is generally significantly faster than SQLite.</gtr:description><gtr:id>87A6D31B-321A-46C8-B276-161FEE2BD42E</gtr:id><gtr:impact>The SQLite project contacted us to find out what they can learn from SQPyte. This discussion is ongoing.</gtr:impact><gtr:outcomeId>58a48a96413210.72950206</gtr:outcomeId><gtr:title>SQPyte</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/pubs/files/sqpyte/</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>75DB0EFF-C4B8-4F96-BFC3-5287608EDA2C</gtr:id><gtr:title>An experimental search-based approach to cohesion metric evaluation</gtr:title><gtr:parentPublicationTitle>Empirical Software Engineering</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/e779fe807738004e9d84b7e0dce000ea"><gtr:id>e779fe807738004e9d84b7e0dce000ea</gtr:id><gtr:otherNames>? Cinn?ide M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58a47e3ddc6823.04198637</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>88C187A4-D6C6-4B9A-AF02-973AEE69AE77</gtr:id><gtr:title>Fine-grained Language Composition: A Case Study</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/78636881a0b7358f0364dc2edb0a30aa"><gtr:id>78636881a0b7358f0364dc2edb0a30aa</gtr:id><gtr:otherNames>Barrett E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58a47d2839caf9.57019995</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>7FC52FF6-18A9-43F9-B4BB-3EC6FF49BD34</gtr:id><gtr:title>Making an Embedded DBMS JIT-friendly</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/4414673dcebb98c31b40adddbb06bdcc"><gtr:id>4414673dcebb98c31b40adddbb06bdcc</gtr:id><gtr:otherNames>Bolz CF</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58a47dc6bbe6a1.34949614</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>A14AB57C-B7FB-45F4-944C-5FB796AD168F</gtr:id><gtr:title>Evaluating and comparing language workbenches</gtr:title><gtr:parentPublicationTitle>Computer Languages, Systems &amp; Structures</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ce6c9f7518113192d739f988eb794379"><gtr:id>ce6c9f7518113192d739f988eb794379</gtr:id><gtr:otherNames>Erdweg S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>563cf87e578721.86115759</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>4804A6CD-F223-49BB-A4B9-317F4C7CA2F1</gtr:id><gtr:title>Virtual machine warmup blows hot and cold</gtr:title><gtr:parentPublicationTitle>Proceedings of the ACM on Programming Languages</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/78636881a0b7358f0364dc2edb0a30aa"><gtr:id>78636881a0b7358f0364dc2edb0a30aa</gtr:id><gtr:otherNames>Barrett E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5a2fe93e308743.11902982</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/L02344X/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>50</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>50</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>