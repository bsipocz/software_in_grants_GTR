<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/68D0E3C9-9246-4CFC-B5E9-48584CF82993"><gtr:id>68D0E3C9-9246-4CFC-B5E9-48584CF82993</gtr:id><gtr:name>University of Manchester</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>Oxford Road</gtr:line1><gtr:city>Manchester</gtr:city><gtr:postCode>M13 9PL</gtr:postCode><gtr:region>North West</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/68D0E3C9-9246-4CFC-B5E9-48584CF82993"><gtr:id>68D0E3C9-9246-4CFC-B5E9-48584CF82993</gtr:id><gtr:name>University of Manchester</gtr:name><gtr:address><gtr:line1>Oxford Road</gtr:line1><gtr:city>Manchester</gtr:city><gtr:postCode>M13 9PL</gtr:postCode><gtr:region>North West</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/86624709-9B24-4BE3-97F9-2611DB4C1685"><gtr:id>86624709-9B24-4BE3-97F9-2611DB4C1685</gtr:id><gtr:firstName>Antoniu</gtr:firstName><gtr:surname>Pop</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FM004880%2F1"><gtr:id>DEA12FE7-DB53-4BB5-B311-CAAE42F007C5</gtr:id><gtr:title>Hybrid Static / Dynamic Optimisations for Many-Cores: Breaking the Memory Wall</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/M004880/1</gtr:grantReference><gtr:abstractText>Fueled by an exponential growth in computing capacities, society's reliance on information and computer systems has grown to encompass most activities and aspects of our lives. Mobile computing devices alone are set to outnumber humans in 2014, each such device providing more computational power than the supercomputers used to put men on the moon. Yet despite this exponential growth, society still hungers for more: consumers want new and improved smartphones and computers; scientists want to run more precise simulations, solve bigger problems or get results faster; we explore new computationally intensive technologies to bring forward the next generation of tools, from self-driving cars to robotic surgery. However, the &amp;quot;free lunch&amp;quot; is over: processors are no longer getting faster. Hard physical limits, such as energy and power density, have brought this success story to an abrupt end. To avoid this impasse, all major manufacturers are now offering an exponentially increasing number of processing units, or cores, per chip.

With ubiquitous parallel hardware and stagnating single processor performance, the only way forward is to improve the scalability and efficiency of parallel execution. In this context, the critical impediment to performance is the widening gap between the computing capabilities of many-core architectures and their limited off-chip memory bandwidth: the memory wall. Traditional solutions attempt to reduce off-chip communications by improving data locality, which means that computations are scheduled in such a way that intermediate results are not sent back to main memory and then re-loaded on chip. Common approaches are either static, with an optimising compiler determining a program schedule such that all intermediate results fit within the available cache memory, or dynamic, when a runtime environment builds the schedule during execution.

The main criticism of these techniques is that: (1) static approaches are very limited in scope, only applicable to restricted classes of computations; and (2) dynamic approaches are unaffordable, as finding the optimal schedule is generally more expensive than the gain. Current state-of-the-art approaches favour inexpensive dynamic heuristics, albeit imprecise and sub-optimal. The research hypothesis of this project is that near-optimal dynamic schedules can be built efficiently, provided that the work is partitioned between the compiler and the runtime system. Alone, the compiler cannot optimise many important programs due to static analysis shortcomings when dealing with recursion or complex, dynamically allocated, data structures. However, if the compiler performs best effort static optimisations and prepares the ground by providing the runtime environment with tractable subproblems, which are cheap to solve with the accurate information typically available during execution, then such a hybrid optimisation scheme becomes profitable and will lead to significant performance and scalability gains.</gtr:abstractText><gtr:potentialImpactText>The outcome of this project will deliver performance and scalability gains to software development companies that target multi- and many-core architectures, and as a consequence, it will also enhance consumer experience on computers and mobile devices equipped with new chips, providing faster and less power-hungry applications, an essential gain on smartphones and tablets. The mobile economy is not only one of the fastest growing economic sectors, but it represents a fundamental societal shift.

The most direct beneficiaries, financially speaking, are chip manufacturers. They will increasingly struggle to sell chips as more cores often provide no performance gains to existing applications. One of their main issues will be to find a way to show that new chips, with more cores, have an edge over previous generations, and this crucially depends on the capability of programmers to exploit vast numbers of additional cores. This project will enhance the scalability of parallel programs, which is as relevant to established chip manufacturers, such as ARM, IBM, Intel or Qualcomm, as to start-ups that produce massively parallel many-core processors like Kalray's MPPA architecture.</gtr:potentialImpactText><gtr:fund><gtr:end>2016-06-01</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2015-03-02</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>99988</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs><gtr:disseminationOutput><gtr:description>Aftermath Tutorial at HiPEAC 2017 in Stockholm</gtr:description><gtr:form>Participation in an activity, workshop or similar</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>1C69F5E4-E5B0-48BD-9471-0AE43C51616E</gtr:id><gtr:impact>Trace-based, post-mortem analysis has been established as a key technique for the performance analysis of parallel programs. It provides insight into the dynamic aspects of program execution that are inaccessible to static analysis, such as the interaction between the application, the run-time system, the operating system and the hardware. Existing tools for trace-based analysis provide various performance metrics, including function call profiles, hardware performance counter data and memory allocation, but only few tools are able to relate performance data to the programming and execution model.
This tutorial introduced and provided hands-on experience with Aftermath, a graphical tool for the analysis of OpenMP and OpenStream programs, specifically designed for cross-layer, language-centric performance analysis, relating low-level performance data to high-level concepts of the programming language, run-time, and application.

Out of the ~40 registered attendants, two academics mentioned that they had already started using the tool for research and for teaching, and two expressed their intent to use the tool in their courses. One industry attendant discussed plans to develop a R&amp;amp;D project around the tool.</gtr:impact><gtr:outcomeId>58b45d8a8f0626.88445052</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Professional Practitioners</gtr:primaryAudience><gtr:url>https://www.hipeac.net/events/activities/7447/aftermath/</gtr:url><gtr:year>2017</gtr:year></gtr:disseminationOutput></gtr:disseminationOutputs><gtr:exploitationOutputs/><gtr:furtherFundingOutputs><gtr:furtherFundingOutput><gtr:amountPounds>780069</gtr:amountPounds><gtr:country>European Union (EU)</gtr:country><gtr:currCode>EUR</gtr:currCode><gtr:currCountryCode>Austria</gtr:currCountryCode><gtr:currLang>de_AT</gtr:currLang><gtr:description>H2020 FET-HPC</gtr:description><gtr:end>2018-09-02</gtr:end><gtr:fundingOrg>European Research Council (ERC)</gtr:fundingOrg><gtr:fundingRef>H2020-671578</gtr:fundingRef><gtr:id>7F0EFFA5-48B0-4812-8450-66BBC91789E8</gtr:id><gtr:outcomeId>56d6cd4c23dad5.31129346</gtr:outcomeId><gtr:sector>Public</gtr:sector><gtr:start>2015-10-01</gtr:start></gtr:furtherFundingOutput><gtr:furtherFundingOutput><gtr:amountPounds>3300</gtr:amountPounds><gtr:country>European Union (EU)</gtr:country><gtr:currCode>EUR</gtr:currCode><gtr:currCountryCode>Austria</gtr:currCountryCode><gtr:currLang>de_AT</gtr:currLang><gtr:description>Cross Site Proposal</gtr:description><gtr:end>2016-04-02</gtr:end><gtr:fundingOrg>EUROLAB4HPC</gtr:fundingOrg><gtr:id>D3D368B2-C3C8-45F6-BA77-21EF568E2028</gtr:id><gtr:outcomeId>56d6cc05379c21.59058755</gtr:outcomeId><gtr:sector>Public</gtr:sector><gtr:start>2016-03-01</gtr:start></gtr:furtherFundingOutput><gtr:furtherFundingOutput><gtr:amountPounds>457406</gtr:amountPounds><gtr:country>United Kingdom of Great Britain &amp; Northern Ireland (UK)</gtr:country><gtr:currCode>GBP</gtr:currCode><gtr:currCountryCode>United Kingdom</gtr:currCountryCode><gtr:currLang>en_GB</gtr:currLang><gtr:description>University Research Fellowship</gtr:description><gtr:end>2019-12-02</gtr:end><gtr:fundingOrg>Royal Academy of Engineering</gtr:fundingOrg><gtr:id>244ACC06-5B29-4EB4-9ABF-3E94F0A6C98C</gtr:id><gtr:outcomeId>56d6ca1bcb08d1.19039085</gtr:outcomeId><gtr:sector>Learned Society</gtr:sector><gtr:start>2015-01-01</gtr:start></gtr:furtherFundingOutput></gtr:furtherFundingOutputs><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>Dynamic task parallelism is an increasingly popular programming model on shared-memory systems. Compared to data parallel loop-based concurrency, it promises enhanced scalability, load balancing and locality. These promises, however, are undermined by non-uniform memory access (NUMA) systems, an unavoidable evolution for scalability.

We found that it is possible to preserve the uniform hardware abstraction of contemporary task-parallel programming models, for both computing and memory resources, while achieving near-optimal data locality. We designed and implemented run-time algorithms for NUMA-aware task and data placement that are fully automatic, application-independent, performance-portable across NUMA machines, and adapt to dynamic changes in application behaviour. Placement decisions use information about inter-task data dependences and reuse. This information is readily available in the run-time systems of modern task-parallel programming frameworks, and from the operating system regarding the placement of previously allocated memory. Our algorithms take advantage of data-flow style task parallelism, where the privatization of task data enhances scalability through the elimination of false dependences and enables fine-grained dynamic control over the placement of application data.

We demonstrated that the benefits of dynamically managing data placement outweigh the privatization cost, even when comparing with target-specific optimizations through static, NUMA-aware data interleaving. Our implementation and the experimental evaluation on a set of high-performance benchmarks executing on a 192-core system with 24 NUMA nodes show that the fraction of local memory accesses can be increased to more than 99%, resulting in a speedup of up to 5x compared to a NUMA-aware hierarchical work-stealing baseline.</gtr:description><gtr:exploitationPathways>Our scheduling and memory allocation techniques could benefit most other asynchronous many-task (AMT) parallel programming environments, such as OpenMP, StarSs, Cilk, Habanero/X10 or TBB.

Furthermore, we have included these optimisations in the runtime system of the OpenStream programming language (http://openstream.info), so any application implemented using this language will directly benefit from our results.</gtr:exploitationPathways><gtr:id>876E4F06-9402-48BF-861D-E83A108C4FD1</gtr:id><gtr:outcomeId>56d87f832dd828.81879518</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors><gtr:url>http://www.openstream.info/</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>Aftermath is a graphical tool for the trace-based performance analysis of OpenMP and OpenStream programs. The tool allows programmers to relate performance data from a parallel execution to the programming model, e.g. to loops and tasks in OpenMP. Aftermath supports the interactive exploration of trace files, the generation of detailed statistics for arbitrary subsets of a trace on-the-fly and the inspection of individual events in detail.
Aftermath enables fine grained model-centric analysis of parallel programs, in particular allowing to detect performance anomalies and to find correlations between low-level hardware, runtime or operating system events and the performance anomalies observed during parallel execution.</gtr:description><gtr:id>95905847-88B6-406E-A783-E0E047ED79C9</gtr:id><gtr:impact>The Aftermath tool for parallel program execution analysis has attracted significant interest from a wide range of academic and industrial partners, in particular attracting 40 participants at a tutorial organised jointly with the HiPEAC 2017 conference in Stockholm. It is currently used for teaching parallel programming at institutions in France and Germany.
The tool was instrumental in enabling research that resulted in a Best Paper Award at PACT 2016.</gtr:impact><gtr:outcomeId>58b45a15ea36a7.45521807</gtr:outcomeId><gtr:title>Aftermath</gtr:title><gtr:type>Software</gtr:type><gtr:url>https://www.aftermath-tracing.com/</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>BD416C29-B84B-4D5B-8B80-4097F3B119D3</gtr:id><gtr:title>Interactive visualization of cross-layer performance anomalies in dynamic task-parallel applications and systems</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/31b1fd2718961e2ba53e646910a97bbe"><gtr:id>31b1fd2718961e2ba53e646910a97bbe</gtr:id><gtr:otherNames>Drebes A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58b439e1941935.90379668</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>175AD0F9-7A9F-4540-8C7A-DAD36A50243F</gtr:id><gtr:title>Fuse</gtr:title><gtr:parentPublicationTitle>ACM Transactions on Architecture and Code Optimization</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/e08ff929b9a2b30eacab84326842ebfd"><gtr:id>e08ff929b9a2b30eacab84326842ebfd</gtr:id><gtr:otherNames>Neill R</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:issn>15443973 15443566</gtr:issn><gtr:outcomeId>5a9e52cd1aaed4.88154763</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>E32E3FE9-9986-4B3D-AEC7-AD4770020FC8</gtr:id><gtr:title>NUMA-aware scheduling and memory allocation for data-flow task-parallel applications</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/31b1fd2718961e2ba53e646910a97bbe"><gtr:id>31b1fd2718961e2ba53e646910a97bbe</gtr:id><gtr:otherNames>Drebes A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>585d473ac73189.16492982</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/M004880/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>