<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations><gtr:collaborator url="http://gtr.ukri.org:80/organisation/39D10893-E08C-494F-A9C0-FFD70B1BDF35"><gtr:id>39D10893-E08C-494F-A9C0-FFD70B1BDF35</gtr:id><gtr:name>Oracle Corporation</gtr:name><gtr:address><gtr:line1>New England Development Center</gtr:line1><gtr:line2>One Oracle Drive</gtr:line2><gtr:line3>Nashua</gtr:line3><gtr:region>Outside UK</gtr:region><gtr:country>United States</gtr:country></gtr:address></gtr:collaborator></gtr:collaborations><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/318B5D98-4CB4-4B10-A876-08FC93071A56"><gtr:id>318B5D98-4CB4-4B10-A876-08FC93071A56</gtr:id><gtr:name>King's College London</gtr:name><gtr:department>Informatics</gtr:department><gtr:address><gtr:line1>Capital House</gtr:line1><gtr:line2>2nd Floor, Guys Campus</gtr:line2><gtr:line3>42 Weston Street</gtr:line3><gtr:line4>London</gtr:line4><gtr:postCode>SE1 3QD</gtr:postCode><gtr:region>London</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/318B5D98-4CB4-4B10-A876-08FC93071A56"><gtr:id>318B5D98-4CB4-4B10-A876-08FC93071A56</gtr:id><gtr:name>King's College London</gtr:name><gtr:address><gtr:line1>Capital House</gtr:line1><gtr:line2>2nd Floor, Guys Campus</gtr:line2><gtr:line3>42 Weston Street</gtr:line3><gtr:line4>London</gtr:line4><gtr:postCode>SE1 3QD</gtr:postCode><gtr:region>London</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/39D10893-E08C-494F-A9C0-FFD70B1BDF35"><gtr:id>39D10893-E08C-494F-A9C0-FFD70B1BDF35</gtr:id><gtr:name>Oracle Corporation</gtr:name><gtr:address><gtr:line1>New England Development Center</gtr:line1><gtr:line2>One Oracle Drive</gtr:line2><gtr:line3>Nashua</gtr:line3><gtr:region>Outside UK</gtr:region><gtr:country>United States</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role><gtr:role><gtr:name>COLLABORATOR</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/50A1DE17-1630-406A-BAAA-5ADFD19C5E3B"><gtr:id>50A1DE17-1630-406A-BAAA-5ADFD19C5E3B</gtr:id><gtr:firstName>Laurence</gtr:firstName><gtr:surname>Tratt</gtr:surname><gtr:orcidId>0000-0002-5258-3805</gtr:orcidId><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/C2677D47-BEB8-4563-8F10-C6F20B74F84B"><gtr:id>C2677D47-BEB8-4563-8F10-C6F20B74F84B</gtr:id><gtr:firstName>Carl Friedrich</gtr:firstName><gtr:surname>Bolz</gtr:surname><gtr:roles><gtr:role><gtr:name>RESEARCHER</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FK01790X%2F1"><gtr:id>030BA102-B5D7-442F-950A-1461A0ABE963</gtr:id><gtr:title>COOLER: COmpOsing LanguagE Runtimes</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/K01790X/1</gtr:grantReference><gtr:abstractText>Traditionally, most software projects have been tackled using a single programming language. However, as our ambitions for software grow, this is increasingly unnatural: no single language, no matter how &amp;quot;good&amp;quot;, is well-suited to everything. Increasingly, different communities have created or adopted non-traditional languages - often, though not always, under the banner of Domain Specific Languages (DSLs) - to satisfy their specific needs.

Consider a large organisation. Its back-end software may utilise SQL and Java; its desktop software C#; its website back-end PHP and the front-end Javascript and HTML5; reports may be created using R; and some divisions may prototype software with Python or Haskell. Though the organisation makes use of different languages, each must execute in its own silo. We currently have few techniques to allow a single running program to be written using multiple languages. In the Cooler project, we call this the &amp;quot;runtime composition&amp;quot; problem: how can languages execute directly alongside each other, exchange data, call each other, optimise with respect to each other, etc.?

The chief existing technique for composing language runtimes is to translate all languages in the composition down to a base language, most commonly the byte code for one of the &amp;quot;big&amp;quot; Virtual Machines (VMs) - Java's HotSpot or .NET's CLR. Though this works well in some cases, it has two major problems. Firstly, a VM will intentionally target a specific family of languages, and may not provide the primitives needed by languages outside that family. HotSpot, for example, does not support tail recursion or continuations, excluding many advanced languages. Secondly, the primitives that a VM exposes may not allow efficient execution of programs. For example, dynamically typed languages running on HotSpot run slower than their seemingly much less sophisticated &amp;quot;home brew&amp;quot; VMs.

The Cooler project takes a new approach to the composition problem. It hypothesizes that meta-tracing will allow the efficient composition of arbitrary language runtimes. Meta-tracing is a recently developed technique that creates efficient VMs with custom Just-in-Time (JIT) compilers. Firstly, language designers write an interpreter for their chosen language. When that interpreter executes a user's program, hot paths in the code are recorded (&amp;quot;traced&amp;quot;), optimised, and converted into machine code; subsequent calls then use that fast machine code rather than the slow interpreter. Meta-tracing is distinct from partial evaluation: it records actual actions executed by the interpreter on a specific user program. Meta-tracing is an exciting new technique for three reasons. Firstly, it leads to fast VMs: the PyPy VM (a fully compatible reimplementation of Python) is over 5 times faster than CPython (the C-based Python VM) and Jython (Python on the JVM). Secondly, it requires few resources: a meta-tracing implementation of the Converge language was completed in less than 3 person months, and runs faster than CPython and Jython. Third, because the user writes the interpreter themselves, there is no bias to any particular family of languages.

The Cooler project will initially design the first language specifically designed for meta-tracing (rather than, as existing systems, reusing an unsuitable existing language). This will enable the exploration of various aspects of language runtime composition. First, cross-runtime sharing: how can different paradigms (e.g. imperative and functional) exchange data and behaviour? Second, optimisation: how can programs written in multiple paradigms be optimised (space and time)? Finally, the limits of the approach will be explored through known hard problems: cross-runtime garbage collection; concurrency; and to what extent runtimes not designed for composition can be composed. Ultimately, the project will allow users to compose together runtimes and programs in ways that are currently unfeasible.</gtr:abstractText><gtr:potentialImpactText>Programming languages power much of our society, and much of our research, both directly and indirectly. The Cooler project's contributions will thus benefit several other groups. We identify two in particular.

The first group are language designers. Currently, language designers face an unappealing trade-off when designing a new language: spend most of the time on design and get a slow implementation; or spend most of the time on the implementation and get a bad design. Creating a fast language implementation traditionally takes tens of man years (at a minimum), far beyond that which a small team can manage. Slow implementations have problems beyond just making programs slow to run: new language designs are typically ignored when they are part of a slow implementation. In other words, the community as a whole tends to give little credence to language design features until they can be shown to run adequately fast. The more exotic the design, the more the community needs the corresponding implementation to be fast.

The release of Mammal will allow language designers to produce &amp;quot;fast enough&amp;quot; meta-tracing VM implementations with significantly less effort than current approaches. This will allow new language ideas to be evaluated on their merits rather than the size of the team that produced the accompanying implementation. We hope that this will encourage a new age of experimentation in language design, similar to the rapid progress of the 1960s, which may ultimately lead to new solutions for challenges to which current languages struggle with (e.g. concurrency).

To reach language designers, we will focus on community appearances and publicly available and accessibly written articles, ranging from blog-type articles to traditional research papers. We will also hold a summer school towards the end of the project to engage with interested parties.

Software developers form the second group of beneficiaries. Mammal will lead to an increase in the number of languages with fast implementations. This is likely to increase the current trend for developers to experiment with 'non-mainstream' languages (e.g. Clojure, Scala), encouraging a wider understanding of the pros and cons of different languages and paradigms.

In the long-term, Cooler will open up a fundamentally new way of implementing systems which have diverse software needs. For example, health systems have multiple aspects (front-ends, reporting systems, storage etc.), each of which is a substantial system in and of itself. A GP's front-end system, amongst other things, collects input from the GP (increasingly using web-based systems), queries various databases, and provides various reports. Each component of this workflow might be most naturally implemented using a different language (perhaps Javascript, C# / Linq, R), yet developers have to choose one language and use it for all aspects. Cooler will enable language implementers to provide runtimes which can be composed with others. Software developers will then use this ability to implement systems in novel ways.</gtr:potentialImpactText><gtr:fund><gtr:end>2017-08-02</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2013-06-03</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>618883</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs><gtr:collaborationOutput><gtr:collaboratingOrganisation>Oracle Corporation</gtr:collaboratingOrganisation><gtr:country>United Kingdom of Great Britain &amp; Northern Ireland (UK)</gtr:country><gtr:department>Oracle Corporation UK Ltd</gtr:department><gtr:description>Visualizing Cross-Language Execution</gtr:description><gtr:id>D303F7A1-E135-4EFA-A7F7-9C4BC24E1604</gtr:id><gtr:impact>Not currently applicable.</gtr:impact><gtr:outcomeId>58a47f3cd51dc8.86102679-1</gtr:outcomeId><gtr:partnerContribution>We have regular meetings with two members of Oracle Labs; they have provided ideas, and data to validate our ideas.</gtr:partnerContribution><gtr:piContribution>I am the PI on this project investigating the visualisation of program execution in the face of language composition.</gtr:piContribution><gtr:sector>Private</gtr:sector><gtr:start>2016-01-01</gtr:start></gtr:collaborationOutput></gtr:collaborationOutputs><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>A proof-of-concept composition of Python and Prolog.</gtr:description><gtr:id>995ADDC6-D468-4554-A813-05804586D396</gtr:id><gtr:impact>Research prototype.</gtr:impact><gtr:outcomeId>545dfdd4db3eb1.17167079</gtr:outcomeId><gtr:title>Unipycation</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/src/unipycation/</gtr:url><gtr:yearFirstProvided>2014</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>PyHyp is the first large-scale language composition of two real-world languages: in this case PHP and Python. It consists of a fast virtual machine to execute PyHyp programs and special editor support via the Eco tool to make writing composed programs plausible.</gtr:description><gtr:id>BD79BF99-7B35-409C-A512-C7A26D6D2740</gtr:id><gtr:impact>Too early to state.</gtr:impact><gtr:outcomeId>58a48a17431b63.32603891</gtr:outcomeId><gtr:title>PyHyp</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/pubs/files/pyhyp/</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>libkalibera contains reimplementations of the benchmarking method method the following two papers:
 * Rigorous benchmarking in reasonable time. Tomas Kalibera, Richard Jones
 * Quantifying performance changes with effect size confidence intervals. Tomas Kalibera, Richard Jones
libkalibera started off as a pure Python module by the Cooler project team, but support for other languages has since been added by other people.</gtr:description><gtr:id>FEB13E8C-30FF-44C7-9BCA-793660649A7F</gtr:id><gtr:impact>libkalibera has been added to and used by other authors e.g.:
 Dynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages. Matthias Grimmer, Chris Seaton, Thomas Wuerthinger, Hanspeter Moessenboeck. Modularity 2015 (to appear)</gtr:impact><gtr:outcomeId>545e02f4025688.78005163</gtr:outcomeId><gtr:title>libkalibera</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/src/libkalibera/</gtr:url><gtr:yearFirstProvided>2014</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>SQPyte takes the widely used SQLite database and converts part of it into a fast meta-tracing virtual machine. When called regularly from a programming language, SQPyte is generally significantly faster than SQLite.</gtr:description><gtr:id>B09A80AA-9AA5-4B44-B3B1-66ADBDF66996</gtr:id><gtr:impact>The SQLite project contacted us to find out what they can learn from SQPyte. This discussion is ongoing.</gtr:impact><gtr:outcomeId>58a48a96413210.72950206</gtr:outcomeId><gtr:title>SQPyte</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://soft-dev.org/pubs/files/sqpyte/</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>261B5ACC-F5A4-4B59-853D-E732AAF829F9</gtr:id><gtr:title>Sound gradual typing: only mostly dead</gtr:title><gtr:parentPublicationTitle>Proceedings of the ACM on Programming Languages</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/dbbe04e23b76f3a51745204a174a14a4"><gtr:id>dbbe04e23b76f3a51745204a174a14a4</gtr:id><gtr:otherNames>Bauman S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5a7c8fe72dd6c4.01681419</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>24FB261F-884C-4B79-ADB2-76D26FD1BECD</gtr:id><gtr:title>Making an Embedded DBMS JIT-friendly</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/4414673dcebb98c31b40adddbb06bdcc"><gtr:id>4414673dcebb98c31b40adddbb06bdcc</gtr:id><gtr:otherNames>Bolz CF</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58a47dc6bbe6a1.34949614</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>AFDBB3E6-748C-430E-8FE0-A67BAD97A67F</gtr:id><gtr:title>Fine-grained Language Composition: A Case Study</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/78636881a0b7358f0364dc2edb0a30aa"><gtr:id>78636881a0b7358f0364dc2edb0a30aa</gtr:id><gtr:otherNames>Barrett E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58a47d2839caf9.57019995</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>8A4E9033-BDB6-43ED-BB96-1DE484487B84</gtr:id><gtr:title>Adaptive just-in-time value class optimization for lowering memory consumption and improving execution time performance</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ca04d061e1cd603e32641082aed3191a"><gtr:id>ca04d061e1cd603e32641082aed3191a</gtr:id><gtr:otherNames>Pape T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>58a47e0942bb70.68468408</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>671A120B-126A-4AF9-B284-3590D42C2C45</gtr:id><gtr:title>Record data structures in racket</gtr:title><gtr:parentPublicationTitle>ACM SIGAPP Applied Computing Review</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ca04d061e1cd603e32641082aed3191a"><gtr:id>ca04d061e1cd603e32641082aed3191a</gtr:id><gtr:otherNames>Pape T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5a7c90123f85a8.35662720</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>2EC8DFA3-C9D8-4457-A88C-8F87D9E63CA6</gtr:id><gtr:title>Virtual machine warmup blows hot and cold</gtr:title><gtr:parentPublicationTitle>Proceedings of the ACM on Programming Languages</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/78636881a0b7358f0364dc2edb0a30aa"><gtr:id>78636881a0b7358f0364dc2edb0a30aa</gtr:id><gtr:otherNames>Barrett E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5a2fe93e308743.11902982</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>54C98F65-20AF-4656-B1D8-41D4C299F30C</gtr:id><gtr:title>Storage strategies for collections in dynamically typed languages</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/6d6fad97e260ed165023831515b7237d"><gtr:id>6d6fad97e260ed165023831515b7237d</gtr:id><gtr:otherNames>Bolz C F</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>doi_53d075075e1d2b69</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>A050EFE8-03C7-4FF8-AFA9-0FF77FB3F780</gtr:id><gtr:title>Meta-tracing makes a fast Racket</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/6d6fad97e260ed165023831515b7237d"><gtr:id>6d6fad97e260ed165023831515b7237d</gtr:id><gtr:otherNames>Bolz C F</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>543540e375b3e2.05071216</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>8AD77611-323D-4120-BD09-5D69C9D46EC1</gtr:id><gtr:title>Approaches to interpreter composition</gtr:title><gtr:parentPublicationTitle>Computer Languages, Systems &amp; Structures</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/78636881a0b7358f0364dc2edb0a30aa"><gtr:id>78636881a0b7358f0364dc2edb0a30aa</gtr:id><gtr:otherNames>Barrett E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>563cf87d990244.20528463</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>FBCE4839-C3F6-4148-BD49-F94905148061</gtr:id><gtr:title>Pycket: a tracing JIT for a functional language</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/dbbe04e23b76f3a51745204a174a14a4"><gtr:id>dbbe04e23b76f3a51745204a174a14a4</gtr:id><gtr:otherNames>Bauman S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>585d45b298cfb0.49271843</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/K01790X/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>