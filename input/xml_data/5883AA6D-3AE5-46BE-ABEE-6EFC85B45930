<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/D1774113-D5D2-4B7C-A412-66A90FE4B96F"><gtr:id>D1774113-D5D2-4B7C-A412-66A90FE4B96F</gtr:id><gtr:name>University of Cambridge</gtr:name><gtr:department>Computer Laboratory</gtr:department><gtr:address><gtr:line1>Lensfield Road</gtr:line1><gtr:line4>Cambridge</gtr:line4><gtr:postCode>CB2 1EW</gtr:postCode><gtr:region>East of England</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/D1774113-D5D2-4B7C-A412-66A90FE4B96F"><gtr:id>D1774113-D5D2-4B7C-A412-66A90FE4B96F</gtr:id><gtr:name>University of Cambridge</gtr:name><gtr:address><gtr:line1>Lensfield Road</gtr:line1><gtr:line4>Cambridge</gtr:line4><gtr:postCode>CB2 1EW</gtr:postCode><gtr:region>East of England</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/D62539FF-02CC-4DE1-B96E-F004C58ACFC7"><gtr:id>D62539FF-02CC-4DE1-B96E-F004C58ACFC7</gtr:id><gtr:firstName>Neel</gtr:firstName><gtr:surname>Krishnaswami</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FN02706X%2F2"><gtr:id>5883AA6D-3AE5-46BE-ABEE-6EFC85B45930</gtr:id><gtr:title>Semantic Foundations for Interactive Programs</gtr:title><gtr:status>Active</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/N02706X/2</gtr:grantReference><gtr:abstractText>When we first explain how computer programs work to beginners, we tend to explain them as a way of telling a computer how to implement an input-output relation: matrix libraries take a system of linear equations and compute a solution; compilers take a source text as input, and produces an object file as output; and web browsers read an HTML file as input, and then renders it to a screen as output. However, the programs we actually use tend to be interactive. Instead of solving a system of equations once, we might put it into a spreadsheet and incrementally modify the parameters to explore the solution space. Instead of giving a program once to a compiler, we develop within an IDE, with our work flow interleaving the process of writing code and finding and repairing errors in the program. A web browser does not merely display an HTML document, but can programmatically update the page in response to user and server events.

However, implementing interactive programs is generally much more complicated than implementing one-shot input-output behaviour. Programmers do not get the input to their program all at once, but instead they get it piece-by-piece incrementally. Furthermore, the output also has to be produced incrementally, so that the user of a piece of software can observe and react to the output produced so far. As a result, ensuring that the program keeps track of the user inputs and maintains a consistent view of what the user wants is quite difficult. Furthermore, the interactive behaviour of the program also makes it is harder to say what is and is not correct behaviour for the program, so even telling if a program is correct or incorrect can become very difficult.

The purpose of this project is to develop new programming languages that make writing interactive programs easier, in two ways. First, we will develop mathematical techniques to make it easier to formally state what a program should do, and to check that programs are satisfy this specification, and second, we seek to develop implementation techniques that ensure that interactive programs can run efficiently and respond in a timely fashion to user inputs.</gtr:abstractText><gtr:potentialImpactText>Interactive programs pervade software development, and nearly every
program that every person uses is an interactive program. The
proposed research studies the foundations of reactive programming, and
so is likely to be of interest to anyone interested in
understanding, writing, or using interactive programs.

It is useful to imagine the beneficiaries of the proposed research as
falling into three tiers.

The first tier are other researchers in the areas of programming
languages and semantics. Interactive programming supplies many novel
challenges in program verification and type theory, and having a
rigorous mathematical language for talking about time-dependent
properties is very likely to be useful for modelling and proving the
properties of many kinds of software systems beyond interactive
programs. 

The second tier are practitioners interested in building reactive
systems. There is already widespread commercial interest in reactive
programming (for example, see the Reactive Manifesto at
http://www.reactivemanifesto.org), and there are numerous popular
libraries and implementations (such as RxJava, React, Meteor, and
WPF) which support significant amounts of reactive-style programming.

However, each such library implements a different subset of
functionality, with different choices made depending on the facilities
of the underlying language and the performance costs of the chosen
implementation strategies. As a result, it is very difficult to
compare different reactive programming libraries. It is also quite
difficult to understand which facilities are essential, and which
merely add complications without a corresponding benefit in terms
of expressive power. Overall, it is quite difficult to understand
how programmers can build their own abstractions on top of the 
supplied primitives, or even what primitives should (or should not)
be supplied. 

The proposed research takes a foundational approach to this question,
basing the high-level design on fundamental logical concepts, and
seeking to design low-level primitives which are clean and orthogonal
enough to permit formal correctness proofs. This is very likely to
lead to powerful conceptual guidance for working programmers, and the
&amp;quot;Pathways to Impact&amp;quot; document highlights the priority we place on
communicating these ideas to them.

The final tier are users of interactive programs. Everyone who uses a
computer does so through an interactive interface, and so everyone has
an interest in this interface working well. Furthermore, much private,
important, or otherwise security-critical data is communicated to
users via interactive programs, and it is important to ensure not just
that the right data is communicated, but that is made available only
at the right times. 

For example, we might want a guarantee that a banking application
never reveals any financial data before it receives a correct
password. Note the use of the word ``before'': we definitely want the
program to reveal private data, but only after the correct password
has been supplied. It is precisely properties like this that the
proposed research studies, and so I believe that this work will help
make software more secure, reliable and trustworthy.</gtr:potentialImpactText><gtr:fund><gtr:end>2019-02-28</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2016-11-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>96281</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications/><gtr:identifiers><gtr:identifier type="RCUK">EP/N02706X/2</gtr:identifier></gtr:identifiers><gtr:projectHierarchy><gtr:parents><gtr:parent><gtr:id>3F7F6D39-E868-4C76-8153-692F6A4BF53E</gtr:id><gtr:grantRef>EP/N02706X/1</gtr:grantRef><gtr:amount>99362.04</gtr:amount><gtr:start>2016-06-01</gtr:start><gtr:end>2016-07-31</gtr:end><gtr:children><gtr:child rel="Transfer"><gtr:id>5883AA6D-3AE5-46BE-ABEE-6EFC85B45930</gtr:id><gtr:grantRef>EP/N02706X/2</gtr:grantRef><gtr:amount>96281.8</gtr:amount><gtr:start>2016-11-01</gtr:start><gtr:end>2019-02-28</gtr:end><gtr:children/></gtr:child></gtr:children></gtr:parent></gtr:parents></gtr:projectHierarchy><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>