<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/C6D0044A-2CD2-4167-B90B-922AF53E361F"><gtr:id>C6D0044A-2CD2-4167-B90B-922AF53E361F</gtr:id><gtr:name>University of Kent</gtr:name><gtr:department>Sch of Computing</gtr:department><gtr:address><gtr:line1>The Registry</gtr:line1><gtr:line4>Canterbury</gtr:line4><gtr:line5>Kent</gtr:line5><gtr:postCode>CT2 7NZ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/C6D0044A-2CD2-4167-B90B-922AF53E361F"><gtr:id>C6D0044A-2CD2-4167-B90B-922AF53E361F</gtr:id><gtr:name>University of Kent</gtr:name><gtr:address><gtr:line1>The Registry</gtr:line1><gtr:line4>Canterbury</gtr:line4><gtr:line5>Kent</gtr:line5><gtr:postCode>CT2 7NZ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/A396E5E2-28A5-4F3F-B2DA-2EC081A6D4EC"><gtr:id>A396E5E2-28A5-4F3F-B2DA-2EC081A6D4EC</gtr:id><gtr:firstName>Richard</gtr:firstName><gtr:otherNames>Elliott</gtr:otherNames><gtr:surname>Jones</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/AD2C15BF-3BDE-42D9-BDB8-92DDB3441992"><gtr:id>AD2C15BF-3BDE-42D9-BDB8-92DDB3441992</gtr:id><gtr:firstName>Frederick</gtr:firstName><gtr:otherNames>Robert</gtr:otherNames><gtr:surname>Barnes</gtr:surname><gtr:roles><gtr:role><gtr:name>CO_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FH026975%2F1"><gtr:id>ED7E44E8-B86B-453E-8C14-C3D9293050F0</gtr:id><gtr:title>Garbage Collection for Multicore Platforms</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/H026975/1</gtr:grantReference><gtr:abstractText>Developers are increasingly turning to languages like Java and C# for their ease of development, deployment and maintenance. Most applications for the foreseeable future will be written in languages supported by managed runtimes, running on multicore hardware. Particular benefits of managed runtimes include support for automatic dynamic memory management, or 'garbage collection' (GC) and threads. GC allows programs to recycle unused memory automatically, without error-prone programmer intervention. Threading allows a program to run different sequences of instructions in parallel; for instance, a web server might employ a separate thread for each incoming request from internet browsers.One of the most significant recent developments for language implementers is the development of multicore processors, with the number of cores deployed in commodity platforms expected to increase significantly over the next 5 years. The complexity of the processor's access to memory has also increased, in terms of levels of memory hierarchy and in the technology interconnecting processors. However, modern runtime technology has not evolved as fast as hardware technology, and how to fully exploit hardware parallelism remains an open question.This research asks, how can we exploit hardware parallelism, in particular by running multiple user program ('mutator') and GC threads? How can we avoid paying penalties for non-local memory access, but still benefit from multiple paths to memory? How can we take proactive advantage of locality properties? How can we minimise synchronisation between mutator and GC threads?Today's concurrent GC techniques avoid relocating live objects, so as to minimise the need for this synchronisation, but this leads to poor use of memory with many small holes but nowhere to accommodate larger objects ('fragmentation'). The standard fragmentation solution - periodic compaction phases - has high overheads, and often lacks portability or leads to throughput slumps before mutator threads can operate at full speed again. Memory management will be a bottleneck for the next generation of increasingly thread parallel software unless the problem of high performance GC for multicore can be solved. This proposal aims to address this key problem, reconciling compaction with concurrency and performance.We believe that the key to exploiting modern multicore architectures is a judicious division of effort between mutator and GC threads, in order not simply to avoid paying the price of accessing non-local memory, but proactively to process data while it is in the cache. It is almost always worth paying the cost of executing a few more instructions in order to avoid accessing non-local data. Thus, if a mutator thread is about to access data (and hence it is or soon will be in the cache), it should perform some GC work on that data immediately. Other data should be left to be handled by separate GC threads. At no time should all mutator threads be halted waiting for the collector. Our aim is therefore to provide high throughput and very low pauses, by utilising parallel copying collector threads, running concurrently and carefully coupled with mutators in order to leverage locality.This research will benefit GC researchers by broadening the design space and devising and evaluating new concurrent GC techniques, and developers in the broad community through enabling them to tune their applications and GCs to modern architectures. A high-performance GC tuned to modern multicore hardware will also lower the barrier to deployment of future software applications that expect to exploit multicore hardware fully. We will make all code developed freely available under an Open Source license. As well as disseminating our results through journals and conferences, we shall organise two workshops in order to build UK research strength in this field.</gtr:abstractText><gtr:potentialImpactText>The ubiquitous platform for the medium term future (say, the next ten years) will almost certainly be multicore, multi-socket, hardware executing a managed runtime for a language like Java or C#. Such hardware is already ubiquitous on modern desktops and laptops, and will soon appear in more mobile markets (netbooks, high-end phones). It is essential that the next generation of runtimes, such as Java virtual machines in general and their memory management subsystems in particular, can fully exploit the hardware parallelism on offer in order to provide a better experience for end users. JikesRVM is the most widely used platform for research into the implementation of Java Virtual Machines. Currently, JikesRVM/MMTk provides no support for concurrent collectors. If successful, the research proposed here will open up the design space of concurrent, copying collectors. It will also provide a platform for further GC research, by embodying the knowledge gathered into a redesigned MMTk toolkit for building GCs. The 2008 CPHC study of the IT labour market in the UK revealed that, while employers need more technical staff (and IT managers), the supply of computer science graduates is falling, putting the UK's position in the IT industry at risk. A supply of highly skilled, human capital to UK technology companies is essential. This project will train a research assistant and a PhD student, thus contributing to the UK's skills base. We plan to disseminate the results of our research in a variety of effective and appropriate ways. The PI has a track record of promoting research and exchange of ideas. He is author of the definitive book on GC, co-founded the International Symposium on Memory Management, co-established ACM SIGPLAN/EAPLS Semantics, Program Analysis and Computing Environments for memory management as a regular workshop series, edited a special issue on memory management of the journal Science of Computer Programming, and maintains the widely used online GC bibliography, www.cs.ukc.ac.uk/~rej/gcbib/gcbib.html. Coordinating the UK Memory Management Network (GR/R57140), he regularly brings together academic and industrial researchers and developers. The intensity of interest in this area was exemplified by the oversubscribed 2008 Workshop on Language and Runtime Support for Concurrent Systems, which attracted attendees from the UK, Europe and the USA. This proposal plans two further workshops on the same theme, which will provide an opportunity not only for researchers to exchange ideas but will also build UK research strength in this field.</gtr:potentialImpactText><gtr:fund><gtr:end>2014-02-28</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2010-09-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>383969</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>Our findings have potential use for any organisation developing high performance garbage collectors. Our finding that, for certain special cases, software transactional memory may offer the same performance as Intel's hardware transactional memory extensions, while offering the advantage of portability, may have a wider application.</gtr:description><gtr:firstYearOfImpact>2010</gtr:firstYearOfImpact><gtr:id>4BE61891-9629-439C-B524-DFD0D45CB468</gtr:id><gtr:impactTypes><gtr:impactType>Economic</gtr:impactType></gtr:impactTypes><gtr:outcomeId>5448f3fbaafbc8.42327268</gtr:outcomeId><gtr:sector>Digital/Communication/Information Technologies (including Software),Education</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>1) By comparing the cache behaviour of mutator insertion and deletion write barriers for concurrent/incremental collectors, in a VM, GC and hardware agnostic manner, we demonstrate for the first time that deletion barriers generate more work for a concurrent GC than insertion barriers, but find that the time between triggering a write barrier on an object and subsequently using it can be much lower with a deletion barrier than an insertion barrier, suggesting that deletion barriers may lead to better cache performance than has hitherto been expected.



2) Garbage collectors must update all references to objects they move. Updating is a lengthy operation but the updates must be transparent to the mutator running concurrently with the collector. The consequence is that no space can be reclaimed until all references have been updated. One solution is to replace direct references to objects with handles: these eliminate the updating problem and allow immediate reuse of the space used by evacuated objects.However, the execution time overhead of handles has led to them being abandoned by most modern systems. We demonstrate optimisations for handles that nearly eliminate their overhead compared with other widely used real-time collectors.

3) We found for the first time that the hardware support for transactions provided by the more recent editions of Intel processors (Transactional Synchronization Extensions) can be used to improve the performance of a fully concurrent, replicating garbage collector provided that (i) care is taken to move as much work as possible outside the transaction, and (ii) there is sufficient work to amortize the cost of setting up a transaction. Using this approach, we obtained improvements in object copying speed of gains of 48-100%.However, we found that it is also possible to match these gains using a novel software transactional memory techniques.

4) The Java language provides programmers with references of several degrees of 'strength'. However, the rules pertaining to the reclamation of objects reachable from weak references are complex and difficult to implement in a fully concurrent garbage collector. This task is made more difficult by the informal, English language explanation of the rules. We formalised these rules using mathematics, and implemented a high-performance, fully concurrent collector that handle reference types correctly (and in doing so, fixed bugs in a widely used Java virtual machine).

5) Building garbage collectors that are both performant and correct is hard. Building fully concurrent, defragmenting collectors is even more so. Our design methodology emphasises a tricolour abstraction (representing the collector's knowledge of each object in the heap), invariants between objects expressed in terms of the abstraction that both user program and garbage collector must maintain, and simple model checking. We demonstrate that this methodology is effective in constructing the most complex garbage collectors, and gives assurance of their correctness.

6) Increasing levels of hardware parallelism are one of the main challenges for managed runtimes. Any concurrency or scalability improvements must be evaluated experimentally but application benchmarks available today may not reflect the highly concurrent applications we anticipate in the future and may also behave in ways that VM developers do not expect. We provide a set of platform independent concurrency-related metrics and an in-depth observational study of current state of the art benchmarks, discovering how concurrent they really are, how they scale the work and how they synchronise and communicate via shared memory.



7) Experimental evaluation is key to systems research. Because modern systems, and especially concurrent systems, are complex and non-deterministic, good experimental methodology forces researchers to account for uncertainty. Unfortunately the standards of reporting in computer science are often poorly by comparison with other disciplines. One cause may be researchers' reluctance to spend large amounts of time conducting experiments in order to account sufficiently for variation. This paper provides for the first time a statistically rigorous methodology for repetition and summarization of results methodology for repetition and summarization of results. Time efficiency comes from two key observations. First, a given benchmark on a given platform is typically prone to much less non-determinism than the common worst-case of published corner-case studies. Second, repetition is most needed where most uncertainty arises (whether between builds, between executions or between iterations of a program). We capture experimentation cost with a novel mathematical model, which we use to identify the number of repetitions at each level of an experiment necessary and sufficient to obtain a given level of precision. We present our methodology as a cookbook that guides researchers on how to obtain reliable results.</gtr:description><gtr:exploitationPathways>Our work is of significance to any vendor of managed runtime languages, such as Java or C#. 

Our formalisation of java's weak reference types complements the informal description found only in the class documentation for java.lang.Reference. Use of this precise, mathematical specification allows Java VM implementors to confirm their understanding of the rules that apply to Java's weak reference types. 

Our development methodology is applicable to any garbage collector. It provides an effective way to develop correct collectors.

Our recommendations for rigorous benchmarking not only demonstrate how to make robust performance comparisons between different versions of a system, but also how to do so at least cost of a developer's time.

We plan to make our tools and data open source in order to provide the greatest benefit to the community, academic and non-academic.</gtr:exploitationPathways><gtr:id>2050595C-43D7-4CE3-BEFF-09B63EB4A2BC</gtr:id><gtr:outcomeId>r-9346627452.733587774263a</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors><gtr:url>http://www.cs.kent.ac.uk/projects/gc/mirrorgc</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs><gtr:researchMaterialOutput><gtr:description>The answer to the type of method is inappropriate but the least bad match. researchfish should fix this.

We describe a method for experimental computer science that is rigorous yet minimises the amount of experiment time required (minimises the number of repetitions required). We also show how to use the method to quantify performance changes with effect-size confidence intervals. While the use of effect sizes is known in other scientific disciplines, it seems to have been ignored in computer science.</gtr:description><gtr:id>A5ED9845-780B-42DD-8505-EC4ABE34D79A</gtr:id><gtr:impact>The method has been used by other researchers, e.g. Tratt's group at Kings College London. Software has also been made available on request.</gtr:impact><gtr:outcomeId>5448f9519b1330.28458565</gtr:outcomeId><gtr:providedToOthers>true</gtr:providedToOthers><gtr:title>Rigorous bennchmarking in reasonable time</gtr:title><gtr:type>Improvements to research infrastructure</gtr:type><gtr:url>http://www.cs.kent.ac.uk/~rej/</gtr:url><gtr:yearFirstProvided>2013</gtr:yearFirstProvided></gtr:researchMaterialOutput><gtr:researchMaterialOutput><gtr:description>The &amp;quot;Type of research tool or method&amp;quot; response above is inappropriate but the least bad match. researchfish should fix this.

We provide tools for analysing the scalability and concurrency bottlenecks in Java programs</gtr:description><gtr:id>09A87EFB-088B-4113-9CDA-100A4D5DB829</gtr:id><gtr:impact>Not known other than our OOPSLA 2012 paper</gtr:impact><gtr:outcomeId>5448f77942bc28.01597131</gtr:outcomeId><gtr:providedToOthers>true</gtr:providedToOthers><gtr:title>Tools for black-box understanding of concurrency of Java programs</gtr:title><gtr:type>Improvements to research infrastructure</gtr:type><gtr:url>http://www.cs.kent.ac.uk/projects/gc/dacapo/</gtr:url><gtr:yearFirstProvided>2012</gtr:yearFirstProvided></gtr:researchMaterialOutput></gtr:researchMaterialOutputs><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>Source code of the tools used in our paper, A Black-box Approach to Understanding Concurrency in DaCapo, Tomas Kalibera, Matthew Mole, Richard Jones and Jan Vitek, OOPSLA 2012, doi: 10.1145/2398857.2384641, ACM</gtr:description><gtr:id>1A02DEB6-E056-4C70-85C3-FC90D3949F0D</gtr:id><gtr:impact>OOPSLA 2012 paper</gtr:impact><gtr:outcomeId>542eb14fef97c0.50608520</gtr:outcomeId><gtr:title>Tools for black-box understanding of concurrency of Java programs</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://www.cs.kent.ac.uk/projects/gc/dacapo/</gtr:url><gtr:yearFirstProvided>2012</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>BC7AFB87-F8BA-452B-AE03-174E86C673F5</gtr:id><gtr:title>Exploring garbage collection with haswell hardware transactional memory</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c2bc3dfccabf545296e91a5dc5b2852d"><gtr:id>c2bc3dfccabf545296e91a5dc5b2852d</gtr:id><gtr:otherNames>Ritson C</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>585d452c098874.61848618</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>050367D0-36D9-4F94-AFD1-3D76F4A1EF13</gtr:id><gtr:title>A black-box approach to understanding concurrency in DaCapo</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c4a65294fd624076da7312e81b3b2d28"><gtr:id>c4a65294fd624076da7312e81b3b2d28</gtr:id><gtr:otherNames>Kalibera T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>doi_53d0750758a531a8</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>8FC5471E-1938-4C64-89C2-623FEFF1BE47</gtr:id><gtr:title>Quantifying Performance Changes with Effect Size Confidence Intervals</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/bd52644ce233dede5efedbec5a68c968"><gtr:id>bd52644ce233dede5efedbec5a68c968</gtr:id><gtr:otherNames>Kalibera, T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>542eae8b960146.99713833</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>B3BA4D00-8B1B-4EA1-9E05-993B49B90FCB</gtr:id><gtr:title>Reference object processing in on-the-fly garbage collection</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/90f2c4270ce4e4f4de5ed521f14b463d"><gtr:id>90f2c4270ce4e4f4de5ed521f14b463d</gtr:id><gtr:otherNames>Ugawa T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>585d4524c85366.35530721</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>B3F05DFF-DF0F-419C-B9BE-314DB77C658B</gtr:id><gtr:title>The Garbage Collection Handbook: The Art of Automatic Memory Management</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/82b02f02a2af10a33181777f13f3ebca"><gtr:id>82b02f02a2af10a33181777f13f3ebca</gtr:id><gtr:otherNames>Jones, Richard</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:isbn>978-1-4200-8279-1</gtr:isbn><gtr:outcomeId>i_64241767333c060306</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>62AA3B9E-7B88-431C-8885-4CA5590ECB87</gtr:id><gtr:title>Handles revisited</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c4a65294fd624076da7312e81b3b2d28"><gtr:id>c4a65294fd624076da7312e81b3b2d28</gtr:id><gtr:otherNames>Kalibera T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>doi_55f95e95e9a8e5d5</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/H026975/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>