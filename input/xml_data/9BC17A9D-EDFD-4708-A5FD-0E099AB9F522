<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/ACE617BE-3E38-4485-9965-C2A062A22E3A"><gtr:id>ACE617BE-3E38-4485-9965-C2A062A22E3A</gtr:id><gtr:firstName>Jeremy</gtr:firstName><gtr:surname>Gibbons</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FG034516%2F1"><gtr:id>9BC17A9D-EDFD-4708-A5FD-0E099AB9F522</gtr:id><gtr:title>Reusability and Dependent Types</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/G034516/1</gtr:grantReference><gtr:abstractText>Robin Milner coined the slogan well typed programs cannot gowrong , advertising the strength of typed functional languages like MLand Haskell in using types to catch runtime errors. Nowadays, we canand want to go further: dependently typed programming exploits thepower of very expressive type systems to deliver stronger guaranteesbut also additional support for software development, using types toguide the development process. This is witnessed by a recent surge oflanguage proposals with the goal to harness the power of dependenttypes, e.g. Haskell with GADTs, Agda, Coq, Omega, Concoqtion, Guru,Ynot, Epigram and so on.However, expressive type systems have their price: more specific typesfrequently reduce the reusability of code, whose too-specificimplementation type may not fit its current application. Thisphenomenon already shows up in the traditional Hindley-Milner styletype system of ML and Haskell; it becomes even more prevalent in adependently typed setting. Luckily, all is not lost: dependent typesare expressive enough that they can talk about themselvesreflectively, making meta-programming one of its potential killerapplications with the potential of combining expressive types andreusable software components.Based on and inspired by recent research at Nottingham on dependentlytyped programming (EPSRC EP/C512022/1) and container types (EPSRCEP/C511964/2) and at Oxford on datatype-generic programming (EPSRCGR/S27078/01, EP/E02128X/1) we plan to explore the potential ofdependent types to deliver reusable and reliable softwarecomponents. To achieve this, we intend to explore two alternativeroads - reusability by structure and reusability by design - andexpress both within a dependently typed framework. Our programme is tobuild new tools extending the Epigram 2 framework, investigate theunderlying theory using container types, and most importantlyestablish novel programming patterns and libraries. We seek fundingfor an RA at Nottingham (Peter Morris, whose PhD laid much of thegroundwork for this proposal), and two doctoral students (one each atOxford and Strathclyde), together with appropriate support forequipment, coordination, travel, and dissimination (i.e. a workshopand a summer school)</gtr:abstractText><gtr:fund><gtr:end>2013-10-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2009-10-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>124272</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>One collection of key findings concern the structure of Dybjer's &amp;quot;inductive families&amp;quot; of datatypes, and specifically to McBride's notion of &amp;quot;ornaments&amp;quot; for relating more and less refined variants of structurally similar inductive families. Inductive families all datatypes to incorporate invariants, such as constraints on shape (size, balance) or contents (ordering); red-black trees are an example. Expressing these invariants within the datatype itself make it a type error to break the invariant, which will the type checker will guarantee to catch - rather than a mere logic error, which testing might miss. As well as preventing incorrect programs, more precise typing information also helps in constructing correct programs, by guiding the programmer or their programming tools in defining the right program in the first place. But having to introduce new datatypes just to capture new invariants is bad for reuse, because old libraries are inapplicable to the new datatypes. Ornaments show how to factor the new datatype into an old datatype plus additional information, paving the way for adapting the old library code to be reused on the new datatype. 

Ko's DPhil thesis &amp;quot;Analysis and Synthesis of Inductive Families&amp;quot; presents some elegant and useful results about ornaments. One such result relates to the mathematical foundations behind operations to combine ornamentations, which are needed to support refinement by multiple properties. Another is the introduction of relational algebraic ornaments, in which the properties may be defined in terms of relations rather than total functions; this lends itself very well to techniques for calculating the appropriate index structure for a particular problem, by lifting existing work on calculating programs that refine given relational specifications.

A second collection of key findings concern the formal semantics of effectful coinductive functional programs: the precise treatment of computational effects such as I/O and state in otherwise pure, non-terminating but productive programs. Monads are well studied in pure, terminating functional programming; they play a big part in the design of Haskell. But ironically, given that Haskell is the foremost lazy functional programming language, our understanding of the interaction between effects and infinite data structures is much less mature. For example, we can easily write stateful Haskell programs that generate finite lists, and pure corecursive Haskell programs that generate infinite lists, but it is much trickier to write and reason about a stateful corecursive Haskell program generating an infinite list (because there is typically no final state). 

Pirog's DPhil thesis &amp;quot;Completely Iterative Monads in Semantics of Coinductive Programs&amp;quot; built on theoretical work by Elgot, Moss, Adamek, Milius and others on completely iterative monads, which are monads equipped with a productive corecursion scheme. His thesis presented a study that combined monads for effects with coalgebraic techniques for evolving behaviour. He introduced a formal coinductive semantics parametrised with a completely iterative monad, showing that it instantiates to a number of known approaches, based on metric spaces and final coalgebras. He also showed some results about composability of completely iterative monads; specifically, he explored coinductive resumptions, generalizing previous results by Moggi and by Hyland, Plotkin and Power.</gtr:description><gtr:exploitationPathways>Programming with ornaments would definitely benefit from some more direct language and/or library support, so there is scope for future work here. We have just submitted a paper exploring a worked example and identifying some desirable properties of that additional support.

Pirog's work on the semantics of coinductive effectful programs addresses the meaning of pre-existing programs, but not directly how to construct those programs in the first place. There is work to be done in using these techniques actually to derive programs with desired behaviours from more abstract specifications of those behaviours.</gtr:exploitationPathways><gtr:id>BD612B74-A294-4276-84D6-CE804BF58045</gtr:id><gtr:outcomeId>r-2354727631.76516447773cf14</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors><gtr:url>http://www.cs.ox.ac.uk/projects/rdtp/index.html</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>DA470F2F-1156-41E1-9724-D1CF7E995B41</gtr:id><gtr:title>Tracing monadic computations and representing effects</gtr:title><gtr:parentPublicationTitle>Electronic Proceedings in Theoretical Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7b8bbb482ce2a027e29825309d2298a7"><gtr:id>7b8bbb482ce2a027e29825309d2298a7</gtr:id><gtr:otherNames>Pir?g M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>56cc4ad4594be0.91955586</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>D828B160-738E-4620-8E36-9DFE48E57CF1</gtr:id><gtr:title>Monads for Behaviour</gtr:title><gtr:parentPublicationTitle>Electronic Notes in Theoretical Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7b8bbb482ce2a027e29825309d2298a7"><gtr:id>7b8bbb482ce2a027e29825309d2298a7</gtr:id><gtr:otherNames>Pir?g M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>5460c0218f2d66.26562117</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>A8DE4496-DCD0-46AC-8E19-95FE0AF94A16</gtr:id><gtr:title>Programming with ornaments</gtr:title><gtr:parentPublicationTitle>Journal of Functional Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/0bcc69f0ecf56f031085ee5573d759c2"><gtr:id>0bcc69f0ecf56f031085ee5573d759c2</gtr:id><gtr:otherNames>KO H</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>5a7c3b52133a96.28923207</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>E759D31B-9FFA-4FB3-83C9-9A852DEBBFC4</gtr:id><gtr:title>Relating Algebraic and Coalgebraic Descriptions of Lenses</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/2e8116d255fd2fd91b418da88ec8b9bf"><gtr:id>2e8116d255fd2fd91b418da88ec8b9bf</gtr:id><gtr:otherNames>Gibbons, J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>56cc74aa5f7943.68351040</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>41461A86-F6EB-4C14-B9BB-4F38C12E927E</gtr:id><gtr:title>Modules Over Monads and Their Algebras</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/a83fc20d879cafa1f8854ced5e46dbc7"><gtr:id>a83fc20d879cafa1f8854ced5e46dbc7</gtr:id><gtr:otherNames>Pirog, M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>56cc4b8f655722.04684822</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>74D8C3D3-E858-44AA-A333-A7BA1E56DFEF</gtr:id><gtr:title>The Coinductive Resumption Monad</gtr:title><gtr:parentPublicationTitle>Electronic Notes in Theoretical Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7b8bbb482ce2a027e29825309d2298a7"><gtr:id>7b8bbb482ce2a027e29825309d2298a7</gtr:id><gtr:otherNames>Pir?g M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>5460bf9a9ccd36.27766678</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>EE92F6CE-31E1-4DDD-8EBF-A8B8E354F654</gtr:id><gtr:title>Modularising inductive families</gtr:title><gtr:parentPublicationTitle>Progress in Informatics</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/1ca8a797b1ac0093c77b5871de49eb55"><gtr:id>1ca8a797b1ac0093c77b5871de49eb55</gtr:id><gtr:otherNames>GIBBONS J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>doi_53d0850851039f5f</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>F1D1B2FE-C674-47EA-96A0-4E4FDA04CD37</gtr:id><gtr:title>Kernels, in a nutshell</gtr:title><gtr:parentPublicationTitle>Journal of Logical and Algebraic Methods in Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/e1da6e35b9ceb516bc93168a19b75b6a"><gtr:id>e1da6e35b9ceb516bc93168a19b75b6a</gtr:id><gtr:otherNames>Gibbons J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>5675f031ab935</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/G034516/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>