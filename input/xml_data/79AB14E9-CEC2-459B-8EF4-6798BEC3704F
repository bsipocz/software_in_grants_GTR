<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations><gtr:collaborator url="http://gtr.ukri.org:80/organisation/28DC780F-3CEC-45AB-A937-2F1EC468705B"><gtr:id>28DC780F-3CEC-45AB-A937-2F1EC468705B</gtr:id><gtr:name>Eindhoven University of Technology</gtr:name></gtr:collaborator></gtr:collaborations><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/7A0397DD-E0C6-4EA3-8031-B841D2503C4D"><gtr:id>7A0397DD-E0C6-4EA3-8031-B841D2503C4D</gtr:id><gtr:name>Royal Holloway, University of London</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>Egham Hill</gtr:line1><gtr:line4>Egham</gtr:line4><gtr:line5>Surrey</gtr:line5><gtr:postCode>TW20 0EX</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/7A0397DD-E0C6-4EA3-8031-B841D2503C4D"><gtr:id>7A0397DD-E0C6-4EA3-8031-B841D2503C4D</gtr:id><gtr:name>Royal Holloway, University of London</gtr:name><gtr:address><gtr:line1>Egham Hill</gtr:line1><gtr:line4>Egham</gtr:line4><gtr:line5>Surrey</gtr:line5><gtr:postCode>TW20 0EX</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/28DC780F-3CEC-45AB-A937-2F1EC468705B"><gtr:id>28DC780F-3CEC-45AB-A937-2F1EC468705B</gtr:id><gtr:name>Eindhoven University of Technology</gtr:name><gtr:roles><gtr:role><gtr:name>COLLABORATOR</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/F262B9E0-E9D1-4BFF-B9BF-B4C81D12D8B9"><gtr:id>F262B9E0-E9D1-4BFF-B9BF-B4C81D12D8B9</gtr:id><gtr:name>Microsoft Research Ltd</gtr:name><gtr:address><gtr:line1>21 Station Road</gtr:line1><gtr:postCode>CB1 2FB</gtr:postCode><gtr:region>East of England</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/55D1FC72-C295-40BB-A756-4BA38C69BD11"><gtr:id>55D1FC72-C295-40BB-A756-4BA38C69BD11</gtr:id><gtr:firstName>Adrian</gtr:firstName><gtr:surname>Johnstone</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/4603BE44-F491-4FF2-B0B3-9AA5CD78802F"><gtr:id>4603BE44-F491-4FF2-B0B3-9AA5CD78802F</gtr:id><gtr:firstName>Elizabeth</gtr:firstName><gtr:surname>Scott</gtr:surname><gtr:roles><gtr:role><gtr:name>CO_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FI032509%2F1"><gtr:id>79AB14E9-CEC2-459B-8EF4-6798BEC3704F</gtr:id><gtr:title>PLanCompS: Programming Language Components and Specifications</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/I032509/1</gtr:grantReference><gtr:abstractText>Software comes in many different shapes and sizes: ranging from games and social networking systems through databases and office software to control system for vehicles and medical instrumentation. Regardless of its purpose, software is almost always written in high-level programming languages, which are significantly easier to use than the low-level machine languages which can be executed directly by computers.Before a program written in a high-level language can be run on a particular computer, the language needs to have been implemented on that computer. The implementation could be a compiler, which translates high-level programs to machine code; alternatively, it might directly interpret them, simulating their intended behaviour.Many hundreds of programming languages have been designed and implemented since the 1950s, and dozens are currently in widespread use. Major ones introduced since 1995 include Java, C#, Python, Ruby, OCaml, Delphi, and VBScript. Older languages evolve to incorporate new features: new versions of Fortran, Cobol, Ada, C++, Scheme and Haskell appear at intervals ranging from one to 10 years. New programming languages are continually being designed and implemented, with the aim of making it easier (or at least quicker and cheaper) for programmers to write useful software. So-called domain-specific languages (DSLs) are designed for use in a particular sector, such as banking or engineering, or particular application areas, e.g., interactive web pages; they are often obtained by extending general-purpose languages with features that correspond closely to standard concepts or notation in the targeted sector.The documentation of a language design is called a language specification. This usually consists of a succinct formal grammar, determining the syntax of the language (i.e., which sequences of characters are allowed as programs, and how they are to be grouped into meaningful phrases), together with a lengthy informal explanation of their semantics (i.e., the required behaviour when programs are run), written in a natural language such as English. Unfortunately, such explanations are inherently imprecise, open to misinterpretation, and not amenable to validation.This project will employ innovative techniques for specifying the semantics of languages completely formally. The main novelty will be the creation of a large collection of reusable components of language specifications. Each component will correspond to a fundamental programming construct, or funcon, with fixed semantics. Translation of program phrases to combinations of funcons determines the semantics of the programs, and specifying this translation is much simpler - and much less effort - than specifying their formal semantics directly. The project will test and demonstrate the advantages of this component-based approach to language specification using case studies involving specification of major programming languages (including C# and Java) and DSLs.Sophisticated tools and an integrated development environment will be designed and implemented by the project to support creation and validation of component-based language specifications. The tools will support automatic generation of correct prototype implementations directly from specifications, allowing programs to be run according to their formal semantics. This will encourage language designers to experiment with different designs before initiating a costly manual implementation of a particular design, which may lead to development of better languages.Funcon and language specifications will be stored in an open-access repository, and a digital library interface will support browsing and searching in the repository. The library will also provide access to digital copies of existing formal specifications of programming languages using previous approaches.</gtr:abstractText><gtr:fund><gtr:end>2016-02-28</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2011-09-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>491077</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs><gtr:collaborationOutput><gtr:collaboratingOrganisation>Eindhoven University of Technology</gtr:collaboratingOrganisation><gtr:country>Netherlands, Kingdom of the</gtr:country><gtr:description>TU/e research partnership</gtr:description><gtr:id>B939F48F-672E-4EA6-8E3B-7F883176DE65</gtr:id><gtr:impact>Joint papers (see portfolio). Joint submission of EU Marie Curie proposal (unsuccessful)</gtr:impact><gtr:outcomeId>5459336f2ce778.16388150-1</gtr:outcomeId><gtr:partnerContribution>Joint supervision of students; development of new theory; joint publications</gtr:partnerContribution><gtr:piContribution>Joint supervision of students; development of new theory; joint publications</gtr:piContribution><gtr:sector>Academic/University</gtr:sector></gtr:collaborationOutput></gtr:collaborationOutputs><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>The tooling developed within this project has been used to implement the software for Leverhulme Project Grant 'Notions and Notations: Babbage's Language of Thought'. This project has featured in a BBC documentary on Ada Lovelace, and in the Ada 200 symposium at Oxford in December 2015. The Plan-28 project also hopes to make use of this material - see their blog at http://blog.plan28.org/2015/03/progress-on-understanding-babbages.html and video from the Ada symposium at https://podcasts.ox.ac.uk/series/ada-lovelace-symposium-celebrating-200-years-computer-visionary (item 15).</gtr:description><gtr:firstYearOfImpact>2015</gtr:firstYearOfImpact><gtr:id>B8D5B41A-7B6D-43B2-9523-DAB8C9D647A5</gtr:id><gtr:impactTypes><gtr:impactType>Cultural</gtr:impactType></gtr:impactTypes><gtr:outcomeId>56cc6400995488.73070334</gtr:outcomeId><gtr:sector>Creative Economy,Digital/Communication/Information Technologies (including Software),Education</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>This research has shown that formally specified 'Fundamental Constructs' may be used to define the meaning (or 'semantics') of programming languages by software engineers who lack detailed training in formal semantics. A significant result is that we now have a quite-high language in which to discuss the implementation of programming language processors which is quite easy to understand, yet which may be expanded into a fully formal semantics with unambiguous mathematical foundations.</gtr:description><gtr:exploitationPathways>We shall ourselves move forward with tooling designed to be used by typical software engineers which allows straightforward construction of simple languages and deeper analysis of new programming language constructs in the context of existing languages.

We also expect other groups, some affiliated with this project, to implement these fundamental constructs as an abstraction layer within their formal semantics systems.

Advances have also been made in generalised parsing: in particular we have developed a new method for capturing all possible lexicalisations of a string without requiring a parser to operate at character level (which can be very inefficient). This work is presently being prepared for publication; the PhD student attached to the project has just received his award on the basis of this work. 

We expect these tools to significantly improve the productivity and reliability of system design based on Domain Specific Languages, and Meta-Model Driven Design.</gtr:exploitationPathways><gtr:id>F817876F-3359-406F-870B-589EEA8BF3EC</gtr:id><gtr:outcomeId>56cc62887f2fa9.47727363</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software),Electronics</gtr:sector></gtr:sectors><gtr:url>http://plancomps.org/</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>ART is a generalised parser generator which implements the GLL algorithm in its various forms.

It is under active development; thevfirst full release (as opposed to beta releases used by our immediate collaboarators in Eindhoven and Swansea) will be in 2014.</gtr:description><gtr:id>D6C6C88D-B947-45F0-9574-0BF6254D2DAF</gtr:id><gtr:impact>ART has been used in a prototype model-based engineering tool under development in Eindhoven, and in use by their commercial collaborators (company confidential).</gtr:impact><gtr:outcomeId>54593471a23089.13516497</gtr:outcomeId><gtr:title>ART translator generator tool</gtr:title><gtr:type>Software</gtr:type><gtr:yearFirstProvided>2013</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>36974EBE-7703-4F2C-BA2C-98095EE06897</gtr:id><gtr:title>Modular grammar specification</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/3fb5fd6c92bcb85c131b06ea6f3a9cc1"><gtr:id>3fb5fd6c92bcb85c131b06ea6f3a9cc1</gtr:id><gtr:otherNames>Johnstone A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>545928a41f5110.88704203</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>62FFD3A0-626C-442A-991B-AC37DE099C57</gtr:id><gtr:title>GLL parse-tree generation</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ef6f6e51efdc2a2fcec4a9e4519c773c"><gtr:id>ef6f6e51efdc2a2fcec4a9e4519c773c</gtr:id><gtr:otherNames>Scott E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>5459313cd24b45.81599437</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>472BF0DF-CCDB-4429-9DF6-5099BBD90F3D</gtr:id><gtr:title>Principled software microengineering</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/3fb5fd6c92bcb85c131b06ea6f3a9cc1"><gtr:id>3fb5fd6c92bcb85c131b06ea6f3a9cc1</gtr:id><gtr:otherNames>Johnstone A</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>5459313cab6185.27694347</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>77AB9B66-A895-45A9-BC56-429E59C1C7A0</gtr:id><gtr:title>Structuring the GLL parsing algorithm for performance</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/ef6f6e51efdc2a2fcec4a9e4519c773c"><gtr:id>ef6f6e51efdc2a2fcec4a9e4519c773c</gtr:id><gtr:otherNames>Scott E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58be711f849ce3.91481546</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/I032509/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>