<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/A8967420-49D3-4509-9912-25FB3EC75B74"><gtr:id>A8967420-49D3-4509-9912-25FB3EC75B74</gtr:id><gtr:name>University of Sussex</gtr:name><gtr:department>Sch of Engineering and Informatics</gtr:department><gtr:address><gtr:line1>The Administration</gtr:line1><gtr:line2>Sussex House</gtr:line2><gtr:line3>Falmer</gtr:line3><gtr:line4>Brighton</gtr:line4><gtr:line5>East Sussex</gtr:line5><gtr:postCode>BN1 9RH</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/A8967420-49D3-4509-9912-25FB3EC75B74"><gtr:id>A8967420-49D3-4509-9912-25FB3EC75B74</gtr:id><gtr:name>University of Sussex</gtr:name><gtr:address><gtr:line1>The Administration</gtr:line1><gtr:line2>Sussex House</gtr:line2><gtr:line3>Falmer</gtr:line3><gtr:line4>Brighton</gtr:line4><gtr:line5>East Sussex</gtr:line5><gtr:postCode>BN1 9RH</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/16905ED5-BE39-4883-9301-D8248D0EABE4"><gtr:id>16905ED5-BE39-4883-9301-D8248D0EABE4</gtr:id><gtr:firstName>Bernhard</gtr:firstName><gtr:otherNames>G</gtr:otherNames><gtr:surname>Reus</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FG003173%2F1"><gtr:id>CB157D69-6CE0-4778-8CB2-8AAAFBABE761</gtr:id><gtr:title>From Reasoning Principles for Function Pointers To Logics for Self-Configuring Programs</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/G003173/1</gtr:grantReference><gtr:abstractText>Pointers are an important feature of programming languages used to define dynamically growing and recursive data structures. Many languages provide pointers not just to data but also functions or procedures, i.e. to executable code. In high-level languages code pointers may manifest themselves explicitly in the form of function pointers or appear in disguises, e.g. as methods of objects carrying their own method suites. Thus, function pointers offer high flexibility of code organisation at runtime but their meaning in specification and verification has been poor due to their complexity. In order to build correct software for modern and future languages it is paramount to have logics that permit reasoning about programs including function pointers. It is important that reasoning is local and modular which means that verification can be done simply w.r.t. the part of the heap affected by a piece of code, and independently of other code that is going to be linked at a later stage, respectively.To develop such reasoning principles for code pointers and their disguised appearance as meta-programming features like run-time generation and loading of code is the objective of this project.In software production a huge amount of time goes into testing that programs are free from errors and thus do not show undesired or even harmful behaviour. While testing is only as good as the test data is, a much more rigorous approach is to verify that a program meets a certain specification, for example that it does not lead to memory faults. Programs containing pointers, however, are notoriously difficult to specify, let alone verify. As Sir Tony Hoare said back in 1973: The introduction of pointers into high-level languages has been a step backwards from which we may never recover.'' 30 years later pointers and references are still important language features and program verification is still the costly exception. But the recent development of Separation Logic (by Reynolds, O'Hearn and others) has finally presented us with a handle to tackle the complexity of pointers. It permits local reasoning on the heap, liberating the verifier from specifying and proving that most of the heap does not change when a procedure or command is executed. Alas, so far only pointers on first-order data like numbers or strings profit from this recent enhancement.Function pointers are equally useful however. They are often employed to implement event handling or automatic software configuration. Which handler is used (as callback'') depends on the content of the function pointer registered, i.e. assigned at runtime. Dynamic invocation of code, reminiscent of dynamic dispatch in object-oriented languages, can also be achieved via such pointers. Function pointers are therefore not simply a rare curiosity. In fact, they are commonplace and appear in languages like ML or C. The language C# even has a special type construct for them: delegates. In Java these can be simulated via single method interfaces. Interfaces, however, do not identify methods by type signatures alone which makes it hard to share them across libraries. Java developers address this by creating on-the-fly wrapper objects (proxies).This is a typical instance of a principle called Reflection that denotes the ability to introspect, intercede, and generate code in a programming language and thus constitutes a method of meta-programming. Another important reflection principle is dynamic loading which allows code modules (for instance software plugins for extended functionality) to be loaded at runtime. For such advanced features, some of which are not available in standard object-oriented languages yet, there are no adequate program logics. Therefore, the central objective of this project is to establish program (Hoare-) logics for languages with explicit and implicit code pointers making the benefits of Separation Logic amenable to them.</gtr:abstractText><gtr:fund><gtr:end>2012-04-30</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2008-11-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>390870</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>The hybrid semantics developed during the project in order to prove the soundness of the proposed proof system has been used by other researchers in the are to provide a semantic (and formal) foundation for their work, for instance logical relations. In the recent past the work by Birkedal and others on verification for concurrent systems made use of variations of the step-indexed semantics as produced in out POPL paper.</gtr:description><gtr:firstYearOfImpact>2014</gtr:firstYearOfImpact><gtr:id>11DB7883-9733-4AD8-9F4C-8C0418AD743F</gtr:id><gtr:impactTypes/><gtr:outcomeId>54647a261734c5.65699294</gtr:outcomeId><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>A proof system has been established in order to prove (memory safety) properties of imperative programs that can store procedures in memory. This has been proved sound and implemented in a tool. It has also been investigated how such a tool can support reasoning about reflective programs, i.e. programs that manipulate themselves at runtime.
To prove the correctness of this logic, a new 'hybrid' model has been devised.</gtr:description><gtr:exploitationPathways>Other researchers in the verification community can use our results to support stored procedures in their languages and verifiers. 
The 'hybrid' semantics (based on step indexing and domain theory) has been used in various papers (in notable conferences like POPL) to develop logics for concurrency. The corresponding paper (Birkedal et al) from the publication list has already a citation count of 62 on Google Scholar.. The paper 'Nested Hoare triples and frame rules for higher-order store' that introduced a semantics for nested triples has a citation count of 49 for the proceedings version and 33 for the journal version.</gtr:exploitationPathways><gtr:id>B12E6F70-A343-431E-8993-04D897C342F0</gtr:id><gtr:outcomeId>546477b2545d39.21112805</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors><gtr:url>http://www.informatics.sussex.ac.uk/research/projects/PL4HOStore/</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>Crowfoot is a semi-automated verification tool we have developed for reasoning about programs which store procedures/code on the heap. Crowfoot uses symbolic execution based on separation logic to reason about programs, proving that procedures meet their specifications, which the user provides in the form of pre- and post-conditions. Crucially, the assertion language of Crowfoot includes the nested triples developed by Schwinghammer, Birkedal, Reus and Yang. This is what allows us to reason in a modular way about the behaviour of code stored on the heap.</gtr:description><gtr:id>189288D3-56E0-45D8-B88E-58C1C1FC19E1</gtr:id><gtr:impact>Used in teaching in MSc Advanced Comp Science at Sussex uni.</gtr:impact><gtr:outcomeId>54636d071def09.69549433</gtr:outcomeId><gtr:title>Crowfoot verifier</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://www.informatics.sussex.ac.uk/research/projects/PL4HOStore/crowfoot/</gtr:url><gtr:yearFirstProvided>2012</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>4579ECBA-A707-449C-A225-8AA80C40FBB5</gtr:id><gtr:title>Nested Hoare Triples and Frame Rules for Higher-order Store</gtr:title><gtr:parentPublicationTitle>Logical Methods in Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7d609db7ba4e4f926d59f67fd7d55eca"><gtr:id>7d609db7ba4e4f926d59f67fd7d55eca</gtr:id><gtr:otherNames>Schwinghammer J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>545ba8783f1973.08227096</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>87C96600-735E-4BE6-BB76-C7ABF8C74C58</gtr:id><gtr:title>A step-indexed Kripke model of hidden state</gtr:title><gtr:parentPublicationTitle>Mathematical Structures in Computer Science</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/b42e130e83736738cd1fa19ec3643e44"><gtr:id>b42e130e83736738cd1fa19ec3643e44</gtr:id><gtr:otherNames>SCHWINGHAMMER J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>545ba5cbded750.17077381</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>CD26A858-813D-4FF7-9F61-7C4234AFC67B</gtr:id><gtr:title>Formal reasoning about runtime code update</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c89540c371aea70245ebacd22c5ba7e5"><gtr:id>c89540c371aea70245ebacd22c5ba7e5</gtr:id><gtr:otherNames>Charlton N</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:isbn>978-1-4244-9195-7</gtr:isbn><gtr:outcomeId>545ba581a4e870.40994307</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>064E64F0-7FBB-4234-9407-7446A7C86981</gtr:id><gtr:title>Automata, Languages and Programming</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/6e1a31bf649397f21bc751573843a912"><gtr:id>6e1a31bf649397f21bc751573843a912</gtr:id><gtr:otherNames>Birkedal L</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2008-01-01</gtr:date><gtr:isbn>978-3-540-70582-6</gtr:isbn><gtr:outcomeId>545ba58270b7e1.97757236</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>9BED967B-5645-43D6-89BB-B1B991906465</gtr:id><gtr:title>Specification patterns for reasoning about recursion through the store</gtr:title><gtr:parentPublicationTitle>Information and Computation</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c89540c371aea70245ebacd22c5ba7e5"><gtr:id>c89540c371aea70245ebacd22c5ba7e5</gtr:id><gtr:otherNames>Charlton N</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>545ba5cbb69f22.29802258</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>DAFA7E89-EBE0-49F3-8505-2DD19A838DCF</gtr:id><gtr:title>A decidable class of verification conditions for programs with higher order store</gtr:title><gtr:parentPublicationTitle>Electronic Communications of the EASST</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/9d4ceda58d15a46845781bacc987c6f6"><gtr:id>9d4ceda58d15a46845781bacc987c6f6</gtr:id><gtr:otherNames>charlton na</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2009-01-01</gtr:date><gtr:outcomeId>545bab9f7fb4e3.40828210</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>AF6121C5-1A0E-4D93-8360-390968BD5351</gtr:id><gtr:title>Symbolic Execution Proofs for Higher Order Store Programs</gtr:title><gtr:parentPublicationTitle>Journal of Automated Reasoning</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/938373d8209d943f534cf53e54e288fd"><gtr:id>938373d8209d943f534cf53e54e288fd</gtr:id><gtr:otherNames>Reus B</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>56d99d8c4d9d23.82245786</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/G003173/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>