<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/B6FB652A-60C3-48DD-9A33-075D1F759B48"><gtr:id>B6FB652A-60C3-48DD-9A33-075D1F759B48</gtr:id><gtr:name>University of Warwick</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>Warwickshire</gtr:line1><gtr:line4>Coventry</gtr:line4><gtr:line5>West Midlands</gtr:line5><gtr:postCode>CV4 7AL</gtr:postCode><gtr:region>West Midlands</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/B6FB652A-60C3-48DD-9A33-075D1F759B48"><gtr:id>B6FB652A-60C3-48DD-9A33-075D1F759B48</gtr:id><gtr:name>University of Warwick</gtr:name><gtr:address><gtr:line1>Warwickshire</gtr:line1><gtr:line4>Coventry</gtr:line4><gtr:line5>West Midlands</gtr:line5><gtr:postCode>CV4 7AL</gtr:postCode><gtr:region>West Midlands</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/6173A222-C9EF-4BF1-ABA9-196FFDB1C7E2"><gtr:id>6173A222-C9EF-4BF1-ABA9-196FFDB1C7E2</gtr:id><gtr:firstName>Sara</gtr:firstName><gtr:surname>Kalvala</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/A02A67CD-5E6A-4C05-BA50-CA3D49C3CB9E"><gtr:id>A02A67CD-5E6A-4C05-BA50-CA3D49C3CB9E</gtr:id><gtr:firstName>David</gtr:firstName><gtr:otherNames>James</gtr:otherNames><gtr:surname>Lacey</gtr:surname><gtr:roles><gtr:role><gtr:name>CO_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FD032466%2F1"><gtr:id>ABD99A1A-180F-4307-82E9-5237597692EE</gtr:id><gtr:title>Verification of the optimizing phase of a compiler</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/D032466/1</gtr:grantReference><gtr:abstractText>Computer programs are sets of instructions to make a computer perform a certain task. We write these programs in programming languages that are easy for humans to understand. Computers, however, are simple and want very simple instructions to run (for example, ones that involve just moving, adding or subtracting numbers). So to get programs to run, we need to convert our human readable programs into these simple instructions. To do this we use another computer program called a compiler.It is important that this conversion process does not go wrong - otherwise the computer will not do what we expect it to do. However, compilers are very complicated programs, sometimes having to deal with millions of instructions; it is very hard to know whether the translation is going wrong. Also, most compilers are clever and attempt to improve the program as it is translated. They try to make the program more efficient and that complicates things even further / making it even harder to know whether the translation is correct or not.Luckily, computer programs can be viewed as mathematical objects (like numbers, formulas and equations) and therefore we can prove things about them. This research aims to find ways to prove that compilers do not go wrong - they always do a correct translation. In particular, the research looks at how to prove this even when the compiler is trying to improve the program.</gtr:abstractText><gtr:fund><gtr:end>2009-09-25</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2006-06-26</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>78758</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>The methodology developed have taken the issue of formalizing program transformations forward and have resulted in further training of research students too.</gtr:description><gtr:firstYearOfImpact>2011</gtr:firstYearOfImpact><gtr:id>E78A0F63-7D02-4105-97B3-060EA8D3AFE5</gtr:id><gtr:impactTypes><gtr:impactType>Economic</gtr:impactType></gtr:impactTypes><gtr:outcomeId>54647c47b53354.76666180</gtr:outcomeId><gtr:sector>Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>Computer programs are usually written in what are known as high-level programming languages, such as Java, C, or C++. For these to actually run on a computer, they need to first be translated into a language which can be understood by the hardware, in a process known as compilation.



Compilers are complex programs, which need to ensure not only a correct translation, but also the translation into fast and efficient code. The more one tries to design the compiler in such as a way that the generated code is fast and efficient, the more difficult it becomes to ensure that the translation will always be correct.



In this project we have addressed this issue of improving the code generated by a compiler while having some assurances that this process will not introduce new bugs. To do this we capture the program once it has already been partially translated by a compiler, into what is known as an intermediate representation. We then check very carefully whether the program satisfies some properties which will allow us to change it without changing what the program does. The way one can write down clearly what the program should do, as well as the conditions which need to be satisfied by transformations. is based on a logical, mathematical notation, specifically temporal logic. We have designed this notation to be both expressive as well as capable of allowing the transformations to be applied automatically.



We have shown that this approach actually works, by writing a tool which fits in within a compiler already in use. The SOOT Framework is a set of packages to manipulate Java programs. Our tool takes an intermediate representation of a program which is generated by SOOT, as well as a file containing the transformations we may want to apply on the program (written in the rigorous, logical language), and checks if the transformations can be applied safely, using a technology known as model checking. The model checking not only confirms whether a transformation can be applied, but it also returns information which can help in generating the new, better code. The tool then uses the output from the model checker and the original code to generate the corresponding optimized code. 



The methodology we have developed is general: instead of restricting ourselves to some of the well known transformations (or optimizations), our goal was to develop a framework where software development teams could think of some transformations themselves, and then use our tools both to ensure the correctness of the transformations and to apply them to whichever programs they wished.



Our goal is to be able to semi-automatically prove that the transformations are indeed safe. While we have been able to do so for many of the transformations with which we started out this project, we have decided to also try to capture some very advanced optimizations, particularly used in transforming code to use modern, multi-core computers effectively. For this we have had to make the formal language more powerful and flexible. We are in the process of extending our language and proof tools to support these more advanced optimizations.



We have also been exploring how the methodology can be applied at another important step in program development, namely in removing bugs from the original programs. The difference here is that the methodology cannot just generate any new code as long as it is equivalent to the original one: the new code must look like the original one with the changes made easy to understand and easy to justify as fixing particular bugs. The language for specifying program properties and transformations will have to be slightly different, but we are developing it using our original results as inspiration.</gtr:description><gtr:exploitationPathways>The main task is to integrate the methodology into existing compiler tools with greater user-base. At the moment the student who was trained in the project is working in industry and is very active in the Java Developers community, having even published a book on the subject. This will help to indirectly improve the software development technology across a large population.</gtr:exploitationPathways><gtr:id>FA5A46BF-B1FE-4061-A505-56D6E442E078</gtr:id><gtr:outcomeId>r-2225566182.49562277998128</gtr:outcomeId><gtr:sectors><gtr:sector>Aerospace, Defence and Marine,Creative Economy,Digital/Communication/Information Technologies (including Software),Electronics</gtr:sector></gtr:sectors></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>CDD0367A-7276-41C3-8545-04E35D8FB387</gtr:id><gtr:title>Program transformations using temporal logic side conditions</gtr:title><gtr:parentPublicationTitle>ACM Transactions on Programming Languages and Systems</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/dd9145200df24d2bccd4c20af7e991dc"><gtr:id>dd9145200df24d2bccd4c20af7e991dc</gtr:id><gtr:otherNames>Kalvala S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2009-01-01</gtr:date><gtr:outcomeId>doi_53d0740745ae09bc</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>6FAD73BD-220A-4EED-9AAF-3939B5CD92F4</gtr:id><gtr:title>Verifying Compiling Optimisations Using Isabelle/HOL</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/417dfd2e9b34b848078630e0da50259d"><gtr:id>417dfd2e9b34b848078630e0da50259d</gtr:id><gtr:otherNames>R Warburton</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2009-01-01</gtr:date><gtr:outcomeId>m_24596286461402e270</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>3A4401E8-D691-4234-BC91-AF21B55194B6</gtr:id><gtr:title>Towards the Automated Correction of Bugs</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/33112ceaf566e17eddf91ad89c82041a"><gtr:id>33112ceaf566e17eddf91ad89c82041a</gtr:id><gtr:otherNames>R Warurton</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2009-01-01</gtr:date><gtr:outcomeId>r_198264063763dada06</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/D032466/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>30</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>1E31C833-3A35-4F54-A499-31D0C245B5D5</gtr:id><gtr:percentage>70</gtr:percentage><gtr:text>System on Chip</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>