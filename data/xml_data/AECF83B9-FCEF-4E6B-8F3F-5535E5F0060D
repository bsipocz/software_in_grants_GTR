<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/688661EB-6501-4814-A94E-8B0526236EFB"><gtr:id>688661EB-6501-4814-A94E-8B0526236EFB</gtr:id><gtr:firstName>Thomas</gtr:firstName><gtr:surname>Melham</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FE026745%2F1"><gtr:id>AECF83B9-FCEF-4E6B-8F3F-5535E5F0060D</gtr:id><gtr:title>Abstraction Discovery and Refinement for Model Checking Partially Ordered State Spaces</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/E026745/1</gtr:grantReference><gtr:abstractText>Integrated electronic chips, such as the processor in your laptop, are among the most complex artifacts ever devised by humans. They consist of many millions of interconnected transistors, all working together to run programs. The engineering design of these chips is extremely challenging, and very difficult to get right. Checking that a modern electronics design will produce a chip that does what it's supposed to do occupies up to 80% of the effort in designing a new chip and requires months or years of computer simulation using large banks of computers.Formal verification is an approach to this problem that aims to improve the quality of chip designs using logical reasoning instead of simulation. A mathematical model of the chip design is constructed, and mathematical proofs are done to show that the model describes just those behaviours that we wish the chip itself to have. These models and proofs are usually very complex - far too big for pencil-and-paper mathematics - and specialised computer software is used for them.With formal verification, the functioning of a chip can often be tested and errors discovered far more thoroughly and with much less effort than by simulating it. But there is a problem with this approach too: an accurate and fully detailed mathematical model of a modern chip design would itself be vastly too large and complex to represent and do proofs about, even using state of the art software.An approach to solving this problem is to let the mathematical models we use be abstractions, or simplifications, of the chip designs they represent. Instead of modelling the design in full detail, we represent only its salient features - only those aspects of it which, if got wrong, will produce an error. An abstract model can be much smaller than a fully detailed one, and so be much easier to handle.The difficulty with this method is coming up with an appropriate abstraction. If the abstraction throws away too much information about the design, then it may not say enough about its behaviour to establish that the design does the expected thing. Even worse, such an oversimplification may give a false assurance that the design is right. On the other hand, if we retain too much information about the design, then the model may be too big to be tractable. The problem of finding a good abstraction in general is very difficult and in practice often requires a great deal of human ingenuity and insight.It would be much better to have a way to find good abstractions automatically. One idea is to begin with a fairly crude abstraction, one that simplifies a great deal. If doing proofs with this reveals an error, then we check if there really is an error in the actual design, or if the problem is just an artefact of oversimplification in our model. (There are ways to check this efficiently.) If the error is real, we have found a problem with our design and can repair it. If the error is spurious, then it can give us information that will allow us to refine our abstraction by adding more of the right kind of design detail to it to get a more accurate one. Repeating this process arrives, we hope, at a tractable abstraction that is sufficient for checking our design.This basic idea has many variants and technical subtleties, and there is a rich literature of advanced research on this topic. This project at Oxford will make a contribution to this research by looking at ways of constructing abstractions in a specific modelling and proof framework called Symbolic Trajectory Evaluation (STE). This is one of the most practical formal verification methods; it is used, for example, by Intel. STE provides an especially rich setting for abstractions, but so far most abstractions in STE have been created manually - by experts and with much effort. This research will develop a new abstraction refinement method for STE that will exploit its full potential and make it much easier forengineers to use effectively.</gtr:abstractText><gtr:fund><gtr:end>2010-07-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2006-10-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>160832</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>Computer microprocessor chips are among the most complex artifacts ever devised by humans. They consist of many millions of interconnected transistors, which must all be working perfectly together to run programs. The engineering design of these chips is extremely challenging-and very difficult to get right. Checking that a modern processor design does what its supposed to do occupies up to 80% of the effort in designing a new chip, and requires months or years of computer simula- tion using large banks of computers.

Formal verification is an approach to this problem that improves the quality of chip designs using logi- cal reasoning instead of simulation. A mathematical model of the chip design is constructed, and mathemati- cal proofs are done to show that the model describes just those behaviours that we wish the chip itself to have. These models and proofs are very complex-and much too big for pencil-and-paper mathematics-so highly so- phisticated computer software must be used.

With formal verification, the functioning of a chip can often be tested and errors discovered far more thor- oughly and with much less effort than by simulating it. But there is a problem with this approach too: a fully detailed mathematical model of a modern chip design is itself vastly too large and complex to represent and do proofs about, even using state of the art software.

An approach to solving this problem is to let the mathematical models we use be abstractions, or simplifications, of the chip designs they represent. Instead of modelling the design in full detail, we represent only its salient features-only those aspects needed to catch errors. (The precise mathematical definition of 'abstrac- tion' in this context is fairly technical.) An abstract model can be much smaller than a fully detailed one, and so be much easier to handle.

The difficulty with this method is coming up with an appropriate abstraction. If the abstraction throws away too much information, then it may not say enough about its behaviour to establish that the design is right. Even worse, such an oversimplification may give a false assurance that the design is right. But if we retain too much information, the model may be too big to be tractable. The problem of finding a good abstraction in general is very difficult, and an extremely active and centrally important research topic in this field.

Symbolic Trajectory Evaluation provides an especially rich setting for representing abstractions. But devising these abstractions has always required difficult and creative manual effort by experts. EPSRC project EP/E026745/1 at Oxford developed a method and algorithm for automatically finding candidate abstractions for symbolic trajectory evaluation. This was complemented by a number of computational techniques for adjusting the level of the abstractions found to seek a good fit with the problem. The project employed a research assistant for one year and supported a Doctoral student, Sara Adams, who completed her dissertation and went on to a career at Google. 

Our main results were published at FMCAD 2007, the top peer-reviewed conference in hardware formal verification, where we won a best paper award. The work comprises both theory and experimental results, which have been obtained using a prototype software implementation of our algorithm. Using this we have tested our technique on small to medium sized examples of our own devising.</gtr:description><gtr:exploitationPathways>We have carried forward our research results by investigating the fit between the technical capabilities we developed and industrial practice. This translational work was done under projects funded through the EPSRC Knowledge Transfer Secondment scheme in 2010-2011. These activities identified and characterised the methodological gaps that need to be filled to bring our results into industrial practice at at least one major commercial microelectronics company. Further technical work to fill the gaps is ongoing.</gtr:exploitationPathways><gtr:id>C32ECF1A-4F11-4B87-9DF5-D433B29C42B8</gtr:id><gtr:outcomeId>56e0c41509f807.58101126</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software),Electronics</gtr:sector></gtr:sectors></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>62258E41-73C8-4E6B-9F40-463755E7486B</gtr:id><gtr:title>Abstraction discovery and refinement for model checking by symbolic trajectory evaluation</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/d514320f860542d4b1ce292b5092d443"><gtr:id>d514320f860542d4b1ce292b5092d443</gtr:id><gtr:otherNames>Adams Sara Elisabeth</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>56e0c6bfa79982.33683545</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>3835EA91-4BFC-44AF-8E53-460A5CC4B70F</gtr:id><gtr:title>Automatic Abstraction in Symbolic Trajectory Evaluation</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/4d9dab4fd7ca5707c428ea0824339446"><gtr:id>4d9dab4fd7ca5707c428ea0824339446</gtr:id><gtr:otherNames>S Adams</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2007-01-01</gtr:date><gtr:outcomeId>56e0c5c12901d5.21323835</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/E026745/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>80</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>20</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>