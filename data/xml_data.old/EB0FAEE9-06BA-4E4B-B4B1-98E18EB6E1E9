<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/D1774113-D5D2-4B7C-A412-66A90FE4B96F"><gtr:id>D1774113-D5D2-4B7C-A412-66A90FE4B96F</gtr:id><gtr:name>University of Cambridge</gtr:name><gtr:department>Computer Laboratory</gtr:department><gtr:address><gtr:line1>Lensfield Road</gtr:line1><gtr:line4>Cambridge</gtr:line4><gtr:postCode>CB2 1EW</gtr:postCode><gtr:region>East of England</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/D1774113-D5D2-4B7C-A412-66A90FE4B96F"><gtr:id>D1774113-D5D2-4B7C-A412-66A90FE4B96F</gtr:id><gtr:name>University of Cambridge</gtr:name><gtr:address><gtr:line1>Lensfield Road</gtr:line1><gtr:line4>Cambridge</gtr:line4><gtr:postCode>CB2 1EW</gtr:postCode><gtr:region>East of England</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/455203A4-9781-4725-A589-223CA5AD2E10"><gtr:id>455203A4-9781-4725-A589-223CA5AD2E10</gtr:id><gtr:name>Australian National University (ANU)</gtr:name><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/FB728485-8E29-4F35-872F-BDBC1C4D96D8"><gtr:id>FB728485-8E29-4F35-872F-BDBC1C4D96D8</gtr:id><gtr:name>Galois Connections</gtr:name><gtr:address><gtr:line1>3875 SW Hall Blvd</gtr:line1><gtr:line2>Beaverton</gtr:line2><gtr:line3>OR 97005</gtr:line3><gtr:region>Outside UK</gtr:region><gtr:country>United States</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/371F6B6C-B53D-4330-AB87-DD1B601638B7"><gtr:id>371F6B6C-B53D-4330-AB87-DD1B601638B7</gtr:id><gtr:firstName>Mike</gtr:firstName><gtr:surname>Gordon</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole><gtr:personRole url="http://gtr.ukri.org:80/person/57362CC4-A385-4264-92FD-26020FCA774D"><gtr:id>57362CC4-A385-4264-92FD-26020FCA774D</gtr:id><gtr:firstName>Hasan</gtr:firstName><gtr:surname>Amjad</gtr:surname><gtr:roles><gtr:role><gtr:name>RESEARCHER</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FF067909%2F1"><gtr:id>EB0FAEE9-06BA-4E4B-B4B1-98E18EB6E1E9</gtr:id><gtr:title>Expressive Multi-theory Reasoning for Interactive Verification</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/F067909/1</gtr:grantReference><gtr:abstractText>As established by a panel of distinguished researchers and industrial users, Grand Challenge #6 for computer science is Dependable Systems Evolution: The vision of GC6 is of a future in which all computer systems justify the trust that society increasingly places in them. One of the key notions of what it means to be dependable is verifiability, i.e., one can guarantee that the computer system does what it is supposed to do. The highest possible level of verifiability is called formal verification , which produces a mathematical proof of a system's reliability.Formal verification for hardware and software is now widely used in mission-critical real-world applications. These include the embedded code in NASA deep space probes, the arithmetic chips in Intel and AMD CPUs, and device driver code in large consumer operating systems such as Microsoft Windows. To achieve the highest level of quality assurance, formal verification is now an essential complement to testing and simulation.Formal verification relies critically on the automation of proof methods for the mathematical theories that are used to describe systems. Automated proof can be done deductively, by proceeding via composition of simple proof rules, or non-deductively, by directly exploiting our knowledge of these theories. Non-deductive proof is fast, but the reliability of deductive proof is more obvious because it can be broken up into simple pieces.In an ideal world, non-deductive proof automation programs are used as oracles for deductive ones. The difficulty is in coming up with deductive versions of the non-deductive program's answers. Achieving a clean and useful integration of non-deductive and deductive proof automation programs is a non-trivial problem.Our research looks at proofs for a relatively new but widely deployed class of non-deductive prover programs called SMT solvers . These are specialised programs for automatically proving assertions about the behaviour of computer systems, when these assertions are expressed as mathematical formulae. We plan to augment SMT solvers to allow more complex assertions to be expressed, and then to explore methods for speeding up the deductive analysis of the answers produced by SMT solvers. Both these objectives will improve the effectiveness of industrial-strength formal verification. In this endeavour we have strong support from both industry and academia. In related previous work we achieved thousands-fold speed-ups in the deductive analysis of Boolean problem solvers, for the first time making deductive verification feasible for industrial Boolean problems. We have high hopes for repeating this success. Success would mean a vastly improved capability for deductive verification, and hence the ability to provide reliable high-level quality-assurance tool kits for considerably more complicated computer systems than is currently possible.</gtr:abstractText><gtr:fund><gtr:end>2011-11-30</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2008-12-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>247157</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>In this project, we integrated Satisfiability Modulo Theories (SMT)
solvers with two popular interactive theorem provers. SMT solvers are
fully automatic provers. By restricting themselves to properties of a
certain kind, SMT solvers achieve astonishing performance even on very
 large problems.


SMT solvers, like any other complex software, harbour bugs. When
verifying safety-critical systems, a bug in the SMT solver could lead
to a bug in our reasoning, with potentially catastrophic consequences:

we might be led to believe that a system is safe when, in fact, it is
 not.


We also integrated Quantified Boolean Formulae (QBF) solvers with
interactive theorem provers in a similar fashion. QBF solvers are
akin to SMT solvers in that they are highly specialized, fully
 automatic provers. However, QBF solvers tackle problems that are more
 complex (in a precise technical sense) than most SMT problems. Their
 integration therefore posed a different challenge, whose efficient
solution required new ideas.


To evaluate our integrations of automatic solvers, we conducted twosubstantial case studies. The first case study established a
fine-grained hierarchy of algebraic structures in the interactive
theorem prover Isabelle/HOL, together with a repository of more than

1000 facts obtained by automated theorem proving. Our results show
 that Isabelle's tool integration makes automated algebraic reasoning
 particularly simple. The second case study established a mathematical
(yet readable) semantics for C++ concurrency. Our formal semantics
 exposed several flaws in the C++11 Draft standard; these have now been
fixed in the final (ISO-approved) version of C++11.</gtr:description><gtr:firstYearOfImpact>2004</gtr:firstYearOfImpact><gtr:id>B185E54E-B929-4A62-8A7B-4549E5B3748B</gtr:id><gtr:impactTypes/><gtr:outcomeId>r-1470193603.5139427d3924958</gtr:outcomeId><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>Interactive theorem provers are software tools that assist with the development of formal proofs. Their applications range from pure mathematics to the verification of safety-critical computer systems. A human expert guides the overall proof search, and the details are filled in by the tool.



With proper guidance, interactive theorem provers can prove the most difficult theorems. Man-machine cooperation is indispensable: many deep theorems will be out of reach of fully automatic provers for the foreseeable future. However, because interactive theorem proving relies on human experts, it is a labour-intensive and therefore costly technology. More automation is needed.



In this project, we integrated Satisfiability Modulo Theories (SMT) solvers with two popular interactive theorem provers. SMT solvers are fully automatic provers. By restricting themselves to properties of a certain kind, SMT solvers achieve astonishing performance even on very large problems.



Our integration allows users of interactive theorem provers to simply hand over proof obligations to the SMT solvers, which will then prove them without further guidance. Proofs that previously would have required dozens of user interactions can now be proved automatically, often in seconds.



SMT solvers, like any other complex software, harbour bugs. When verifying safety-critical systems, a bug in the SMT solver could lead to a bug in our reasoning, with potentially catastrophic consequences: we might be led to believe that a system is safe when, in fact, it is not.



To address this issue, we adopted a sceptical approach in this project: beyond a mere yes/no answer, we require the SMT solver to produce a proof of its result. The proof is then automatically checked in the interactive theorem prover. Proof checking is ultimately performed by a very small - and therefore highly trustworthy - piece of code. SMT solvers may generate proofs that consist of millions of individual reasoning steps; one of the challenges that we had to solve was efficient checking for such large proofs.



We also integrated Quantified Boolean Formulae (QBF) solvers with interactive theorem provers in a similar fashion. QBF solvers are akin to SMT solvers in that they are highly specialized, fully automatic provers. However, QBF solvers tackle problems that are more complex (in a precise technical sense) than most SMT problems. Their integration therefore posed a different challenge, whose efficient solution required new ideas.



To evaluate our integrations of automatic solvers, we conducted two substantial case studies. The first case study established a fine-grained hierarchy of algebraic structures in the interactive theorem prover Isabelle/HOL, together with a repository of more than 1000 facts obtained by automated theorem proving. Our results show that Isabelle's tool integration makes automated algebraic reasoning particularly simple. The second case study established a mathematical (yet readable) semantics for C++ concurrency. Our formal semantics exposed several flaws in the C++11 Draft standard; these have now been fixed in the final (ISO-approved) version of C++11.</gtr:description><gtr:id>10F06B5B-63A5-4622-BEB8-BAD89798F491</gtr:id><gtr:outcomeId>r-5348377577.35362177989b46</gtr:outcomeId><gtr:sectors><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software)</gtr:sector></gtr:sectors></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>13B0F901-D6E1-4D16-8553-B8F4B467C986</gtr:id><gtr:title>SMT solvers: new oracles for the HOL theorem prover</gtr:title><gtr:parentPublicationTitle>International Journal on Software Tools for Technology Transfer</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/e7f5a3ea140ced79540aa13175527d18"><gtr:id>e7f5a3ea140ced79540aa13175527d18</gtr:id><gtr:otherNames>Weber T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:outcomeId>doi_53cfd7fd7ddb77ae</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>E76E2850-2D54-4A1B-827C-357EE6BF88A7</gtr:id><gtr:title>EPSRC Final Report</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/258267c634afc1475da9bf39480139c3"><gtr:id>258267c634afc1475da9bf39480139c3</gtr:id><gtr:otherNames>Michael Gordon (Author)</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>r_3619471486caca75b2</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/F067909/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>