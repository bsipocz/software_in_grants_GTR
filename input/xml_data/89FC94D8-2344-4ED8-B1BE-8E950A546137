<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/C6D0044A-2CD2-4167-B90B-922AF53E361F"><gtr:id>C6D0044A-2CD2-4167-B90B-922AF53E361F</gtr:id><gtr:name>University of Kent</gtr:name><gtr:department>Sch of Computing</gtr:department><gtr:address><gtr:line1>The Registry</gtr:line1><gtr:line4>Canterbury</gtr:line4><gtr:line5>Kent</gtr:line5><gtr:postCode>CT2 7NZ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/C6D0044A-2CD2-4167-B90B-922AF53E361F"><gtr:id>C6D0044A-2CD2-4167-B90B-922AF53E361F</gtr:id><gtr:name>University of Kent</gtr:name><gtr:address><gtr:line1>The Registry</gtr:line1><gtr:line4>Canterbury</gtr:line4><gtr:line5>Kent</gtr:line5><gtr:postCode>CT2 7NZ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/4476E3F1-8C9D-4E60-9A1A-E6D0AD0F0249"><gtr:id>4476E3F1-8C9D-4E60-9A1A-E6D0AD0F0249</gtr:id><gtr:name>Runtime Verification Inc</gtr:name><gtr:address><gtr:line1>102 E Main St #207</gtr:line1><gtr:postCode>61801</gtr:postCode><gtr:region>Outside UK</gtr:region></gtr:address><gtr:roles><gtr:role><gtr:name>PROJECT_PARTNER</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/EE371CA8-B2B4-4714-A62C-F207A9300F2A"><gtr:id>EE371CA8-B2B4-4714-A62C-F207A9300F2A</gtr:id><gtr:firstName>Radu</gtr:firstName><gtr:surname>Grigore</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FR012261%2F1"><gtr:id>89FC94D8-2344-4ED8-B1BE-8E950A546137</gtr:id><gtr:title>Fast Runtime Verification via Machine Learning</gtr:title><gtr:status>Active</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/R012261/1</gtr:grantReference><gtr:abstractText>When programmers make mistakes, costs can be huge. Programmers make mistakes because they are human. To help them, researchers are developing tools. No tool is a silver bullet; each has advantages and disadvantages. We focus on one kind of tool: the runtime verifiers. Programmers use runtime verifiers more and more, which attests to their utility. Runtime verifiers observe a program while it runs and look for signs that something is amiss. This slows down the program, which is why runtime verifiers are used only by programmers, before releasing the program to users. If runtime verifiers would be more efficient and would not slow down programs so much, then they could remain active in released programs, which would make them more useful. For example, they could be used for detecting security intrusions in deployed systems.

This research project is focused on increasing the efficiency of runtime verifiers.


A Cambridge study from 2013 estimated that the worldwide cost of fixing software defects to be $310 billion per year. A large part of this cost is programmer time. The interval between finding a defect and fixing it is not so small because the task is often not so easy. Some defects are security vulnerabilities, which makes the fixing interval a window of opportunity for criminals. The window of opportunity is bigger than the fixing interval because it also includes the time until users decide to update their software. The size of the window of opportunity is important. For example, updating software regularly is recommended by the UK government, in its Cyber Essentials Scheme. This guidance was issued after a government study showed that, in 2014, nine out of ten large organisations in UK suffered security breaches, and each security breach had an average cost of 1.5 million pounds.

Runtime verifiers could be used to reduce the window of opportunity that criminals have, as follows. Programmers describe scenarios that should not happen. A runtime verifier then observes the program while it runs and, if one of the forbidden scenarios does happen, then the runtime verifier can take an action. For example, the runtime verifier could be instructed to kill the program, because a program crash is preferable to a security breach. Alas, such a use case for runtime verifiers is unrealistic at the moment, because no user would tolerate a program that runs ten times slower than usual just for the benefit of extra protection against security intrusions. In this project we aim at finding a better trade-off. We want the program to run only slightly slower than usual and, in return, we are willing to give up some of the guarantees offered by a runtime verifier, but not much. But, how to find a good trade-off? The key will be using a toolkit developed recently in the machine learning community.</gtr:abstractText><gtr:potentialImpactText>Let us describe a vision, an ideal outcome, in which everything in this research proposal goes according to plan. By the end of 2019, the TOPL runtime verifier will be a reliable and efficient tool that developers use increasingly. Using TOPL, developers deliver software with two versions: standard and hardened. The hardened version is slightly slower but comes with extra protections. With high probability, when a developer assumption is violated, the hardened version informs them. Also with high probability, security intrusions relying on software defects are intercepted and interrupted.

There will be some limitations. For example, TOPL works only with the Java programming language and the TOPL property-specification language. It might be that the latter is not expressive enough in some situations. However, the basic techniques we will develop will not be tied-in with either Java or TOPL. Authors of other runtime verifiers will want to adapt our techniques to their tools. Some of these tools will be academic (such as MarQ, LARVA, Mufin); others will be commercial (such as RV-Monitor and RV-Predict). Tools like AdressSanitizer, which are widely used and have characteristics similar to runtime verifiers, may also make use of some of our techniques.

Ultimately, progress in the area of runtime verification will lead to higher quality software, which will reduce the economic cost of software. Developers will spend a smaller fraction of their time fixing mistakes. Security intrusions will be successful less often.</gtr:potentialImpactText><gtr:fund><gtr:end>2019-12-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2018-01-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>100917</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications/><gtr:identifiers><gtr:identifier type="RCUK">EP/R012261/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>41593421-CFAC-411D-94A7-E144022B0E6D</gtr:id><gtr:percentage>30</gtr:percentage><gtr:text>Artificial Intelligence</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>70</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>