<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/30A429E3-83B7-4E41-99C0-14A144F07DFE"><gtr:id>30A429E3-83B7-4E41-99C0-14A144F07DFE</gtr:id><gtr:name>University of Southampton</gtr:name><gtr:department>Electronics and Computer Science</gtr:department><gtr:address><gtr:line1>Administration Building</gtr:line1><gtr:line2>Highfield</gtr:line2><gtr:line4>Southampton</gtr:line4><gtr:line5>Hampshire</gtr:line5><gtr:postCode>SO17 1BJ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/30A429E3-83B7-4E41-99C0-14A144F07DFE"><gtr:id>30A429E3-83B7-4E41-99C0-14A144F07DFE</gtr:id><gtr:name>University of Southampton</gtr:name><gtr:address><gtr:line1>Administration Building</gtr:line1><gtr:line2>Highfield</gtr:line2><gtr:line4>Southampton</gtr:line4><gtr:line5>Hampshire</gtr:line5><gtr:postCode>SO17 1BJ</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/D9E78EE3-BB51-4A83-8E8E-3E526DBE61E1"><gtr:id>D9E78EE3-BB51-4A83-8E8E-3E526DBE61E1</gtr:id><gtr:firstName>Gennaro</gtr:firstName><gtr:surname>Parlato</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FM008991%2F1"><gtr:id>554AD2A8-483E-4942-899B-ED6437A079FF</gtr:id><gtr:title>CONSEQUENCER: Sequentialization-based Verification of Concurrent Programs with FIFO channels</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/M008991/1</gtr:grantReference><gtr:abstractText>The steady exponential increase in processor performance 
has reached the inevitable turning point, at which it is no longer feasible to
increase the clock speeds of individual processors. To achieve
higher performance, processors now contain several cores that work in parallel.
Consequently, concurrency has become an important aspect across many
areas within computer science, such as algorithms, data structures, programming
languages, software engineering, testing, and verification.
Concurrent programs consist of several computations or threads that are
active at the same time and communicate through some control mechanism, such as
locks and shared variables, or message passing. Concurrent programming is difficult:
programmers do not only have to guarantee the correctness
of the sequential execution of each individual thread, they must also consider
nondeterministic interferences from other threads. Due to these complex
interactions, considerable resources are spent to repair buggy concurrent
software.

Testing remains 
the most used (and often the only known) paradigm in industry to find errors,
even though the inherently nondeterministic nature of the concurrent
schedules causes errors that manifest rarely and are difficult to reproduce and repair.
Testing is not effective in detecting such concurrency errors, as all
possible executions of the programs have to be explored explicitly.
Consequently, testing needs to be complemented by automated verification tools that
enable detection of errors without explicitly (i.e. symbolically) exploring executions. 

On the other hand, the state of the art for concurrent program verification lags behind that for sequential programs.
Here, researchers have successfully explored a wide range of techniques and
tools to analyse real-world sequential software.
A recently proposed approach for symbolic verification of concurrent programs 
called sequentialization, consists in translating the concurrent program 
into an equivalent sequential program so that
verification techniques or tools that were originally designed for
sequential programs can be reused without any changes.

This technique has been successfully used to discover bugs in existing software
and has been implemented in several tools (e.g., Corral by Microsoft Research).
However, existing sequentialization schemas do not support weak memory models, 
or distributed programs that use message passing. 

In this proposal we address these weaknesses and plan the development of automated verification tools that enable detection of errors in concurrent programs in a systematic and symbolic way. More specifically, we will develop the theory, models and algorithms that underpin sequentialization of concurrent programs that use FIFO channels. This will enable us to capture within a single framework (1) concurrent programs that communicate through shared memory, for the variety of (weak) memory models that are implemented in today's computer architectures, and (2) distributed programs which use a message-passing communication style (i.e., the two most commonly used programming models for concurrency).

A key deliverable of this project will be a set of automatic code-to-code translators, called ConSequencer, for C programs that use Pthread (for shared variables) and MPI (for distributed programs). This will serve as a concurrency plugin for any program verification tool designed for sequential programs. We will evaluate our solutions on publicly available benchmarks using a range of robust sequential verification tools for the C language.</gtr:abstractText><gtr:potentialImpactText>Part of the proposed research is foundational in nature and
thus the primary pathway to impact for the obtained knowledge 
will be through academic publications.
We have identified key international conferences and journals that we will target for
dissemination. They cover the academic communities where our results will be of
most interest. 

In addition to the traditional academic publications,
we will also build a project website that will contain
all relevant information about this project (tools, papers, benchmarks,
evaluation, etc.). A strong focus here will be on providing enough details so
that (1) all experiments can be independently repeated, and (2) all
translations can be independently re-implemented. In particular, we plan to
make all translations available as open-source software.

A key deliverable of this project will be an automatic code-to-code translator
called CONSEQUENCER that sequentializes C programs that use 
Pthreads (for multi-threaded programs with shared variables) and
MPI (for distributed programs). 
We will make CONSEQUENCER available in different
versions, to target different audiences: as a complete black-box verification
tool (i.e., coupled with a sequential verification backend), aimed at
software developers; as an stand-alone concurrency pre-processor, aimed at
practical verification experts; and in source form, aimed at verification researchers and
tool developers. Third, we will participate in competitions for software
verification tools. Such competitions have recently emerged as
both an important driver to shape practical research in program verification
and a good channel for disseminating research results in a condensed form. Our
experience from the last two SV-COMP competitions indicates that a
good competition result translates into immediate impact on the field. Fourth,
and finally, we will contribute further benchmarks for such competitions, in
the form of programs produced by our sequentialization translations. Here, the
impact is longer term and less direct, as it provides incentives to the
developers of sequential verification tools to take the characteristics of
these programs into account. 
 
The technology proposed in this project can be applied to verify
hardware-software designs or applications on advanced computer architectures.
We plan to build on the successful existing
collaborations of ESS with ARM and Imagination. Obviously, the partly
foundational nature of the research, and the small scale of the project, will
make an immediate impact on industrial practice (e.g., in form of industrial
tool applications) difficult. However, the results of this project will serve
to get industrial interest and hence their support. Feedback from these initial
industrial collaborations will also help the PI developing a follow-on project,
which will be a larger and longer-term proposal with direct industrial
involvement. 

Another application of this research is in security, as many attacks exploit
errors in the software implementing the security protocols. The PI is a member
of the GCHQ-supported Centre of Excellence in CyberSecurity Research in
Southampton, and will work through this with the Research Institute in
Automated Program Analysis and Verification and with national security
agencies.

The final pathway to impact is through education of the young researcher and
students. The researcher will benefit by working with the PI and the two
PhD students. He or she will gain detailed knowledge about verification of
concurrent systems and model checking technology, which are areas with a high
demand for (but with low supply of) experts in the UK. The
researcher will also gain experience in supervising research students, which
will be beneficial for a potential further academic career. The PhD students
will benefit by working with the researcher, which will help them in the timely
completion of their PhD programme.</gtr:potentialImpactText><gtr:fund><gtr:end>2016-08-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2015-03-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>98968</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs><gtr:disseminationOutput><gtr:description>UPMARC Summer School</gtr:description><gtr:form>A talk or presentation</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>4EF2A2D9-4321-4181-817D-80A74CA47915</gtr:id><gtr:impact>Lecture series at UPMARC Summer School on Multicore Computing, Uppsala University, Sweden, June 2015</gtr:impact><gtr:outcomeId>58c6cbdd00a5d5.02741889</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Postgraduate students</gtr:primaryAudience><gtr:url>http://www.it.uu.se/research/upmarc/events/SS2015/ss2015/Start.html</gtr:url><gtr:year>2015</gtr:year></gtr:disseminationOutput><gtr:disseminationOutput><gtr:description>FMCAD</gtr:description><gtr:form>A talk or presentation</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>4FDE7EC3-F6B1-439B-89CB-0EB9511F61C2</gtr:id><gtr:impact>Scientific conference presentation. The main purpose of this activity concerns dissemination and exploitation of results.</gtr:impact><gtr:outcomeId>58c81a8878f7a0.84313968</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Professional Practitioners</gtr:primaryAudience><gtr:year>2016</gtr:year></gtr:disseminationOutput><gtr:disseminationOutput><gtr:description>IMT</gtr:description><gtr:form>A talk or presentation</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>486303AA-F0F9-48DA-96AF-78D20E844618</gtr:id><gtr:impact>Teaching: 20-hour module on Verification of Concurrent Programs, PhD program, IMT School for Advanced Studies, Lucca, Italy, April 2016</gtr:impact><gtr:outcomeId>58c6ccb8bde451.70803319</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Schools</gtr:primaryAudience><gtr:year>2016</gtr:year></gtr:disseminationOutput><gtr:disseminationOutput><gtr:description>ATVA</gtr:description><gtr:form>A talk or presentation</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>B034524E-A0FC-4B8E-A578-4A729B8CEF40</gtr:id><gtr:impact>Scientific conference presentation. The main purpose of this activity concerns dissemination and exploitation of results.</gtr:impact><gtr:outcomeId>58c81b276a4483.94496183</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Professional Practitioners</gtr:primaryAudience><gtr:url>http://atva2016.gforge.inria.fr/</gtr:url><gtr:year>2016</gtr:year></gtr:disseminationOutput><gtr:disseminationOutput><gtr:description>Stellenbosch</gtr:description><gtr:form>Participation in an open day or visit at my research institution</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>17300422-65C0-4E69-85E5-E71FB80B7AE0</gtr:id><gtr:impact>Presentation at the University Paris Diderot presenting work funded by this project.</gtr:impact><gtr:outcomeId>58c81c5577d384.32077227</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Schools</gtr:primaryAudience><gtr:year>2016</gtr:year></gtr:disseminationOutput><gtr:disseminationOutput><gtr:description>TACAS</gtr:description><gtr:form>Participation in an activity, workshop or similar</gtr:form><gtr:geographicReach>International</gtr:geographicReach><gtr:id>3020EF97-4C5B-42A3-B1E1-9107F08DB2C2</gtr:id><gtr:impact>Presentation at the TACAS conference. The main purpose of this activity concerns dissemination and exploitation of results.</gtr:impact><gtr:outcomeId>58c6cf5c28f799.78755613</gtr:outcomeId><gtr:partOfOfficialScheme>false</gtr:partOfOfficialScheme><gtr:primaryAudience>Professional Practitioners</gtr:primaryAudience><gtr:url>http://www.etaps.org/2015/tacas</gtr:url><gtr:year>2015,2016</gtr:year></gtr:disseminationOutput></gtr:disseminationOutputs><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs><gtr:impactSummaryOutput><gtr:description>The approach based on Lazy-CSeq has been used/adapted for the analysis of concurrent software at Amazon Web Services. Also, the company diffblue has expressed the intention to develop a new verification tool for concurrent Java programs based on our approaches. Lazy-CSeq has also been adapted to handle automobile software by others.</gtr:description><gtr:firstYearOfImpact>2016</gtr:firstYearOfImpact><gtr:id>F837834F-CEF5-4C1F-BE79-02E745AA5344</gtr:id><gtr:impactTypes><gtr:impactType>Societal</gtr:impactType></gtr:impactTypes><gtr:outcomeId>56ddde13ed99c9.02710934</gtr:outcomeId><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software),Education,Electronics,Financial Services, and Management Consultancy,Security and Diplomacy</gtr:sector></gtr:impactSummaryOutput></gtr:impactSummaryOutputs><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>We have developed four new techniques based on sequentialization both for finding bugs and proving correctness of concurrent programs that communicate through shared memory (by means of FIFO channels/weak memory models). Sequentialization consists in rewriting concurrent programs so that verification techniques or tools that were originally designed for sequential programs can be reused without any changes. We have implemented a framework, called CSeq, for the development of sequentializations. Within this framework, we have implemented four tools for C concurrent programs. We entered the software verification competition in 2015, 2016 and 2017 and these tools have won gold, silver and bronze medals in the concurrency category of these three editions. Our tools are able to find bugs in complex benchmarks that were out of reach for existing automatic techniques. We have also developed a new approach that combines testing and symbolic methods; its effectiveness is amplified when used on a cluster of computers.</gtr:description><gtr:exploitationPathways>For dissemination and exploitation of results, we are addressing research community through our research publications but also with the help of our tools, and test cases. Competitions (e.g., the SAT-, SMT-, and Software Verification competitions) have become established vehicles to drive research in verification. We have participated in the last three editions of SV-COMP (international software verification competition). Our tools have been used by others to find concurrency bugs in lock-free data structures which are notoriously hard to analyse. Also, it has been used/adapted for the analysis of programs deployed on modern cars.</gtr:exploitationPathways><gtr:id>D1011472-B3C1-4931-A005-23C4D823AF63</gtr:id><gtr:outcomeId>56dde299b33803.33281112</gtr:outcomeId><gtr:sectors><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software),Education,Electronics,Security and Diplomacy,Transport</gtr:sector></gtr:sectors><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs><gtr:softwareAndTechnicalProductOutput><gtr:description>Lazy-CSeq-ABS is a context-bounded verification tool for sequentially consistent C programs using POSIX threads. It first translates a multi-threaded C program into a bounded nondeterministic sequential C program that preserves bounded reachability for all round-robin schedules up to a given number of rounds. It then reuses existing high-performance bounded model checkers as sequential verification backends. Lazy-CSeq handles the full C language and the main parts of the POSIX thread API, such as dynamic thread creation and deletion, and synchronization via thread join, locks, and condition variables. It supports assertion checking and deadlock detection, and returns counterexamples in case of errors. However, the sizes of the individual states still pose problems for further scaling. We therefore use abstract interpretation to minimize the representation of the concurrent program's (shared global and thread-local) state variables. More specifically, we run the Frama-C abstract interpretation tool over the programs constructed by Lazy-CSeq to compute overapproximating intervals for all (original) state variables and then exploit CBMC's bitvector support to reduce the number of bits required to represent these in the sequentialized program. We have implemented this approach in the last release of Lazy-CSeq and demonstrate the effectiveness of this approach; in particular, we show that it leads to large performance gains for very hard verification problems.</gtr:description><gtr:id>0106FC9D-C10A-4593-8D33-DE1EB9E78238</gtr:id><gtr:impact>Lazy-CSeq outperforms other concurrency verification tools and has won the a silver medal in the concurrency category of the international software verification competition SV-COMP'17.</gtr:impact><gtr:outcomeId>58c95bfc80a629.39354076</gtr:outcomeId><gtr:title>LAzy-Cseq-abs</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>Swarm-based verification methods split the original verification task into a large number of simpler independent subtasks and so exploit the availability of large numbers of computational cores to speed up verification. Here, we use a swarm-based method with Lazy-CSeq as verification engine for the individual subtasks. The key idea of our approach is to constrain the interleavings such that context switches can only happen within prescribed windows (i.e., contiguous code segments within the individual threads). This under-approximates the program's behaviors, with the number and size of windows as additional parameters, which allows to vary the complexity of the verification subtasks. We further re- duce the number of subtasks required to achieve a given coverage target with a randomized placement of the windows. This significantly improves Lazy-CSeq's peak memory consumption and (wall-clock) verification time.</gtr:description><gtr:id>8FCC38FE-9EB2-4C7F-8987-5C3CF79FD31A</gtr:id><gtr:impact>Lazy-CSeq-Swarm won the bronze medal in the concurrency category of the international software verification competition SV-COMP'17.</gtr:impact><gtr:outcomeId>58ca4a06bfa940.22014172</gtr:outcomeId><gtr:title>LAzy-CSeq-Swarm</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>Sequentializations are mostly designed for bug finding in concurrent programs. In contrast, UL-CSeq's lazy sequentialization can be used to construct correctness proofs for programs with unbounded loops and an unbounded num- ber of context switches. UL-CSeq 1.0 implements an improved code-to-code transformation that works well for both bounded model checking and proof- constructing sequential verification backends. This version also supports more backends, including CBMC, which gives it a bug finding performance similar to that of Lazy-CSeq, and SeaHorn and VVT, which yield substantial performance gains over the previous release for proof construction. UL-CSeq can thus be used as an effective tool for both bug finding and proof construction by running in parallel multiple backends over the same sequentialized program.</gtr:description><gtr:id>A4E7D4AE-36AA-43AD-B6B8-F80E3D6E1902</gtr:id><gtr:impact>UL-CSeq 1.0 participated in the concurrency category of international software verification competition SV-COMP'17.</gtr:impact><gtr:outcomeId>58ca4b647ee6e0.46335146</gtr:outcomeId><gtr:title>UL-CSeq</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url><gtr:yearFirstProvided>2016</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>MU-CSeq is a context-bounded verification tool for sequentially consistent C programs using POSIX threads. It first translates a multi-threaded C program into a bounded nondeterministic sequential C program that preserves bounded reachability. It then reuses existing high-performance bounded model checkers as sequential verification backends. MU-CSeq handles the full C language and the main parts of the POSIX thread API, such as dynamic thread creation and deletion, and synchronization via thread join, locks, and condition variables. It supports assertion checking.</gtr:description><gtr:id>C4FEA467-B5C4-4BB3-8535-0436334CB2A5</gtr:id><gtr:impact>MU-CSeq outperforms other concurrency verification tools and has won the 1 gold and 2 silver medals in the concurrency category of the last 3 editions of the international software verification competition SV-COMP.</gtr:impact><gtr:outcomeId>56ddd6a8dfca69.41453222</gtr:outcomeId><gtr:title>MU-CSeq</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url><gtr:yearFirstProvided>2015</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput><gtr:softwareAndTechnicalProductOutput><gtr:description>Lazy-CSeq is a context-bounded verification tool for sequentially consistent C programs using POSIX threads. It first translates a multi-threaded C program into a bounded nondeterministic sequential C program that preserves bounded reachability for all round-robin schedules up to a given number of rounds. It then reuses existing high-performance bounded model checkers as sequential verification backends. Lazy-CSeq handles the full C language and the main parts of the POSIX thread API, such as dynamic thread creation and deletion, and synchronization via thread join, locks, and condition variables. It supports assertion checking and deadlock detection, and returns counterexamples in case of errors.</gtr:description><gtr:id>E7AA9CD5-4933-40BB-9A3F-4C6ADFD887A3</gtr:id><gtr:impact>Lazy-CSeq outperforms other concurrency verification tools and has won the 2 gold and 1 silver medals in the concurrency category of the last 3 editions of the international software verification competition SV-COMP.</gtr:impact><gtr:outcomeId>56ddd71df0af01.78656503</gtr:outcomeId><gtr:title>Lazy-CSeq</gtr:title><gtr:type>Software</gtr:type><gtr:url>http://users.ecs.soton.ac.uk/gp4/cseq/cseq.html</gtr:url><gtr:yearFirstProvided>2015</gtr:yearFirstProvided></gtr:softwareAndTechnicalProductOutput></gtr:softwareAndTechnicalProductOutputs><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>19E837C8-7820-416A-8B71-27D31BB8FE8D</gtr:id><gtr:title>Lazy-CSeq: A Context-Bounded Model Checking Tool for Multi-threaded C-Programs</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/a171266277124901914570f388ed1570"><gtr:id>a171266277124901914570f388ed1570</gtr:id><gtr:otherNames>Inverso O</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>565c5581e67920.18999187</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>91B3FFAD-8CE1-4956-9188-13B8BA074897</gtr:id><gtr:title>Concurrent Program Verification with Lazy Sequentialization and Interval Analysis</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/27c9d2bb13e436b0f0454b36e3fd33dc"><gtr:id>27c9d2bb13e436b0f0454b36e3fd33dc</gtr:id><gtr:otherNames>Nguyen T L</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>58c9586916c207.94591874</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>01D09088-3705-44D7-B800-3B074FB36F97</gtr:id><gtr:title>Lazy Sequentialization for TSO and PSO via Shared Memory Abstractions</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/450c568c9c40d8787b8e71ef87998807"><gtr:id>450c568c9c40d8787b8e71ef87998807</gtr:id><gtr:otherNames>Tomasco E</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58bd6bf58fc9d8.19804563</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>AB5345EB-E1CD-43D3-AB86-897733960257</gtr:id><gtr:title>Lazy-CSeq 2.0: combining lazy sequentialization with abstract interpretation: (Competition contribution)</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/27c9d2bb13e436b0f0454b36e3fd33dc"><gtr:id>27c9d2bb13e436b0f0454b36e3fd33dc</gtr:id><gtr:otherNames>Nguyen T L</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>58c95954b6ffb9.71299983</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>65166BCB-4CF8-4ADA-B866-7C0C2DBD91E5</gtr:id><gtr:title>Parallel bug-finding in concurrent programs via reduced interleaving instances</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/18b783a025bc2fdd6d6e89b3dc8bcbb4"><gtr:id>18b783a025bc2fdd6d6e89b3dc8bcbb4</gtr:id><gtr:otherNames>Nguyen T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5aa067deee9179.78350787</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/M008991/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>