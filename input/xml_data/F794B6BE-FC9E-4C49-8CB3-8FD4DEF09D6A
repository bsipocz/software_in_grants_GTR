<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:department>Computer Science</gtr:department><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9"><gtr:id>3EAE04CA-9D62-4483-B9C4-F91AD9F4C5A9</gtr:id><gtr:name>University of Oxford</gtr:name><gtr:address><gtr:line1>University Chest</gtr:line1><gtr:line2>Wellington Square</gtr:line2><gtr:line4>Oxford</gtr:line4><gtr:postCode>OX1 2JD</gtr:postCode><gtr:region>South East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/347995BA-222C-4D4D-9A65-F561A8CA7847"><gtr:id>347995BA-222C-4D4D-9A65-F561A8CA7847</gtr:id><gtr:firstName>Anthony</gtr:firstName><gtr:otherNames>Widjaja</gtr:otherNames><gtr:surname>Lin</gtr:surname><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FH026878%2F1"><gtr:id>F794B6BE-FC9E-4C49-8CB3-8FD4DEF09D6A</gtr:id><gtr:title>A generic transducer-based approach to modelling and verifying infinite-state systems: techniques, applications, and tools</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Fellowship</gtr:grantCategory><gtr:grantReference>EP/H026878/1</gtr:grantReference><gtr:abstractText>Computers have become so complex today that the likelihood of subtle errors is greater than ever before. Moreover, since computerised systems are ubiquitous (e.g. planes, railways, and nuclear power plants), the impact of such errors will certainly be far-reaching. In the past such errors have resulted in a loss of time, money, and even human lives. The development of (fully-automatic) model checking technologies --- pioneered by the recent ACM Turing Award winners Clarke, Emerson, and Sifakis --- has been so influential in minimising the likelihood of subtle errors that model checking has been adopted by major companies including IBM, Intel, Motorola, and NASA. Despite its success, model checking suffers from the inherent state-explosion problem, which remains difficult today even though a substantial progress has been made in the past two decades. The past fifteen years have seen an increasing level of awareness amongst researchers that modelling computerised systems as infinite-state systems is not only more suitable, but might also help circumvent the notorious state-explosion problem. Such a modelling approach views the parameters that cause the state-explosion problem as potentially unbounded or infinite. These include the sizes of arrays, stacks, queues, integer or real valued variables, discrete-time or real-time clocks, and the number of processes in distributed protocols. Instead of the state-explosion problem, such abstractions as infinite-state systems yield undecidability in general. The field of infinite-state model checking aims to develop tools and techniques to deal with this problem. Broadly speaking, approaches to infinite-state model checking can be classified as follows:1. Restrictions to decidable formalisms.2. General (undecidable) formalisms with the aid of decidable semantic restrictions or semi-algorithmsMost research in infinite-state model checking thus far adopts only one of these approaches without seriously considering the other. Moreover, little has been done to see the connections between these two approaches. This is unfortunate since both approaches have their own disadvantages that can be considerably minimised only by considering both approaches in parallel. The project proposes a particular hybrid approach taking into account the two aforementioned approaches simultaneously. The goal is to systematically develop generic tools and techniques for infinite-state model checking aiming for both sound theoretical foundations and practical applicability. This project focuses on general formalisms that are inspired by various notions of finite-state transducers, as they are known to be clean, expressive, and most amenable to theoretical analysis.</gtr:abstractText><gtr:potentialImpactText>I expect that the impact of the proposed research will be far-reaching and especially noticeable among the following groups of people: 1. Research communities including such areas as computer science (e.g. verification, software engineering, and theoretical computer science), operation research, astronomy, and biology. I will make a case for this in Academic Beneficiaries. To ensure that researchers will benefit from this project, I plan to publish regularly at premier conferences in verification (e.g. CAV and LICS), present annually at workshops in verification (e.g. GAMES) and in the more general area of theoretical computer science (e.g. UK's BCTCS), collaborate with researchers, and write accessible surveys summarising the outcomes of the proposed research. I will also make my publications fully accessible to the public by putting them on my website. Finally, the softwares that I will develop will benefit other researchers, who will be able to use and build on them for their research needs. 2. Industry. Many large companies (e.g. IBM, Intel, Motorola, NASA, SUN Microsystems, and UK's own Praxis High Integrity Systems) have been the major consumers of model checking technologies. The proposed research could allow them to fully-automatically verify systems that are far more complex than what current model checking technologies can handle, and therefore significantly reduce the likelihood of subtle errors along with their disastrous impacts to world stability and global economic performance. During the course of the fellowship, I plan to initiate some collaborations with industry. To this end, I plan to present at major verification workshops (e.g. SPIN) which are attended regularly by employees from companies that are interested in model checking (e.g. IBM, Intel, and NASA). I also plan to present the proposed research annually at Oxford Computing Laboratory Industrial Day. Finally, I will also explore some commercialisation avenues through University of Oxford's commercialisation team (ISIS Innovation Ltd). I estimate that the benefits to the industrial sectors will be noticeable in five years, and enormous in 10-15 years. 3. Students. The importance of model checking has prompted many universities in the UK (including Edinburgh and Oxford) and abroad to offer courses on the topic as an integral part of their curricula. The proposed research will benefit such courses by offering new solutions to the state-explosion problem, which is a major topic in model checking. By the end of this project, I plan to develop an advanced course on model checking and write an accessible monograph which incorporate materials from the proposed project. Through this effort, I estimate the benefits of the proposed research to university students will be noticeable in 5 years. 4. Programmers and software developers. The 80/20 rule is a well-known rule of thumb stating that 80% of software development effort is spent on debugging, while the rest is spent on writing codes. Researchers believe that model checking will form an important part of software developer tools in the near future. The proposed project could therefore significantly help programmers to minimise the amount of precious time spent on debugging, which could instead be more fruitfully spent on improving other aspects of their softwares. In the future, I plan to improve the usability of the software tools developed in this project so that every programmer could benefit from them. I estimate this impact will be noticeable in 10 years. 5. General users of computer-operated systems. Such systems are ubiquitous today (which can be found in the planes, railway systems, and nuclear reactors, to name a few). Everybody who lives in the UK, USA, and Europe virtually uses such systems on a daily basis. This project is likely to benefit such people and could potentially save people's lives. I estimate that such benefits will be noticeable in 10-15 years.</gtr:potentialImpactText><gtr:fund><gtr:end>2013-09-30</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2010-10-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>250894</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>The aim of the project is to explore the strengths and weaknesses of generic transducer-based formalism in verification of infinite-state systems. The project has in general met most of the proposed objectives. For example, it is shown that there is a generic semi-algorithm that for safety and liveness for many classes of infinite-state systems (e.g. pushdown automata, tree-rewriting, etc.). So, the theoretical objective was mostly met.

We also discovered several unexpected techniques for analysing specific classes of infinite-state systems along the way, i.e., concurrent programs with numeric data types and recursions. The model captures many features that software developers use when programming. The techniques can be classified as &amp;quot;efficient reduction of analysis of infinite-state systems to SMT-solvers&amp;quot;. We have shown (in our CAV'11 and CAV'12 papers) that they do help make classical techniques more scalable (e.g. now we can verify examples derived from real-world examples including memory resource management code for Linux Device Drivers) and that they have generated new research (at the time of writing, 40 papers have built on top of the result). Finally, this technique also found an application in analysis of graph databases (published in our ACM TODS 2012 paper).</gtr:description><gtr:exploitationPathways>Better methods for analysing software are extremely useful for increasing software quality in general. I think commercialisation and industry collaboration would help create a greater impact to the society/economy.</gtr:exploitationPathways><gtr:id>C34ED8E8-A0E5-409B-A39D-FEA3981A9A68</gtr:id><gtr:outcomeId>56ddae19b33824.43055678</gtr:outcomeId><gtr:sectors><gtr:sector>Digital/Communication/Information Technologies (including Software),Education,Security and Diplomacy</gtr:sector></gtr:sectors><gtr:url>http://homepages.inf.ed.ac.uk/v1awidja/publications.html</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>407C18C5-22F1-414D-A6EB-23E6231C3C38</gtr:id><gtr:title>The Complexity of Model Checking (Collapsible) Higher-Order Pushdown Systems</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/9854eb86d5474c767eb5412d426030ae"><gtr:id>9854eb86d5474c767eb5412d426030ae</gtr:id><gtr:otherNames>Hague, M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2010-01-01</gtr:date><gtr:outcomeId>56dd9c77965d29.83104417</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>BC6A989E-1B58-4E49-8907-6786408E6F29</gtr:id><gtr:title>Accelerating tree-automatic relations</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/a08cd193d42ea3fa3553acffc794b050"><gtr:id>a08cd193d42ea3fa3553acffc794b050</gtr:id><gtr:otherNames>Lin, A.</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>56dd9d74a3ed24.52935895</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>38105F69-5505-43AA-8DC8-595A9FED7856</gtr:id><gtr:title>Concurrency Makes Simple Theories Hard</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/59b57558dfbed900368b9cd63f586d8d"><gtr:id>59b57558dfbed900368b9cd63f586d8d</gtr:id><gtr:otherNames>Goller, S.</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>56dd9ce85d6596.53271849</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>479E255E-D143-4A15-B412-ECB084385CE1</gtr:id><gtr:title>Expressive Languages for Path Queries over Graph-Structured Data</gtr:title><gtr:parentPublicationTitle>ACM Transactions on Database Systems</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/65903af04a38c9395cda29ce9dd77a14"><gtr:id>65903af04a38c9395cda29ce9dd77a14</gtr:id><gtr:otherNames>Barcel? P</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>56dd9e41e451a0.51647850</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>E6AD0669-9E02-4237-8CCA-F27CDBF98C93</gtr:id><gtr:title>The Complexity of Verifying Ground Tree Rewrite Systems</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/7b4f53b2018602caaa7fbb0fa5fb0803"><gtr:id>7b4f53b2018602caaa7fbb0fa5fb0803</gtr:id><gtr:otherNames>Goller S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2011-01-01</gtr:date><gtr:isbn>978-1-4577-0451-2</gtr:isbn><gtr:outcomeId>56dd9b79d4f049.77251655</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>A26710D3-133A-4321-92A6-9F2B821A24C7</gtr:id><gtr:title>Refining the Process Rewrite Systems Hierarchy via Ground Tree Rewrite Systems</gtr:title><gtr:parentPublicationTitle>ACM Transactions on Computational Logic</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/448c0e28dc83bf3259ed3e6ea80d8d5a"><gtr:id>448c0e28dc83bf3259ed3e6ea80d8d5a</gtr:id><gtr:otherNames>G?ller S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:issn>1529-3785</gtr:issn><gtr:outcomeId>5a3519d1c48335.84403742</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/H026878/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>80</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>20</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>