<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/46B41008-0EB4-4E28-BBFB-E98366999EC5"><gtr:id>46B41008-0EB4-4E28-BBFB-E98366999EC5</gtr:id><gtr:name>Durham University</gtr:name><gtr:department>Engineering and Computing Sciences</gtr:department><gtr:address><gtr:line1>Old Shire Hall</gtr:line1><gtr:line2>Old Elvet</gtr:line2><gtr:line4>Durham</gtr:line4><gtr:line5>County Durham</gtr:line5><gtr:postCode>DH1 3HP</gtr:postCode><gtr:region>North East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/46B41008-0EB4-4E28-BBFB-E98366999EC5"><gtr:id>46B41008-0EB4-4E28-BBFB-E98366999EC5</gtr:id><gtr:name>Durham University</gtr:name><gtr:address><gtr:line1>Old Shire Hall</gtr:line1><gtr:line2>Old Elvet</gtr:line2><gtr:line4>Durham</gtr:line4><gtr:line5>County Durham</gtr:line5><gtr:postCode>DH1 3HP</gtr:postCode><gtr:region>North East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/D7F10806-DADF-4898-B707-44150212FE90"><gtr:id>D7F10806-DADF-4898-B707-44150212FE90</gtr:id><gtr:firstName>Shengchao</gtr:firstName><gtr:surname>Qin</gtr:surname><gtr:orcidId>0000-0003-3028-8191</gtr:orcidId><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FE021948%2F1"><gtr:id>AC7E5605-4C15-4F38-88C5-CE813912BFA1</gtr:id><gtr:title>Resource Analysis and Verification for Dependable Embedded Software</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/E021948/1</gtr:grantReference><gtr:abstractText>In recent years, embedded systems have become ubiquitous in our daily life. They are widely built into home electrical appliances, such as washing machines, microwave ovens, dryers and dishwashers. They also exist in mobile devices like PDAs, navigators, mobile phones and smart cards, making our life more convenient and enjoyable. In addition, they are often used in safety critical systems such as military units, medical devices and motor cars. These embedded systems are often supplied with limited memory and computation resources due to various constraints on e.g. product size, power consumption and manufacture cost. Paying insufficient attention to resource issues when developing software for such systems may result in a corresponding software failure after deployment. A real example is the anamoly problem of the Mars Rover Spirit which was due to a memory leakage problem ignored in the software development process. In some cases, such software failure may put human lives at risk. It is thus very important to ensure resource safety and guarantee resource performance for embedded software. We propose to study resource safety and performance for object-oriented (OO) programs running on embedded devices. One aim of our proposed research is to predict statically (i.e. before a program starts to run) and precisely the memory performance of embedded software and to ensure that such software will never require more memory than the device can provide. In addition to memory resource, we will also study timing performance of embedded software which is also of great importance in real-time embedded system design. We intend to develop type-based static analysis techniques to verify memory safety and performance. More specifically, we will keep track of symbolic sizes of data structures which are then used to analyze and infer the memory usage bounds statically (i.e., at compile-time). As a simple example, when a piece of code is about to be downloaded into a mobile phone, our system will be able to check whether the program requires more memory than the phone can provide. We will also develop enhanced region-based memory management mechanisms to improve the overall memory performance of OO programs, where stack-allocated regions will be guided by a symbolic size analysis. This sized-region mechanism is very useful for real-time applications as it can prevent unbounded interference caused by garbage collection. We will also extend our symbolic size analysis to software timing analysis so as to achieve tighter prediction on worst case execution time of OO programs. Based on our research outcomes, we will build a resource analysis and verification tool for embedded software. We believe a more precise resource analysis can help us verify resource safety and possibly tune certain resource-unsafe programs to safe ones. Moreover, it can provide us with an opportunity to reduce the cost of end-user embedded products. This is so as a tighter worst-case execution time would indicate a possibility of using a slower (thus cheaper) hardware processor/device, and a tighter memory usage prediction would suggest that further reduction can be made to the memory footprint to save on hardware size and probably power consumption. We believe a thorough and precise resource analysis would help build more dependable embedded software. Our research outcomes would provide a foundation for building systems with limited resource constraints in a reliable and efficient way.</gtr:abstractText><gtr:fund><gtr:end>2010-07-31</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2007-02-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>213680</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>Embedded software widely exists in home electrical appliances like washing machines, microwave ovens, dryers and dishwashers, in mobile devices like PDAs, navigators, mobile phones and smart cards, as well as in safety critical systems such as military units, medical devices and motor cars. Such systems are often equipped with limited memory footprints due to various constraints on e.g. product size, power consumption and manufacture cost. Paying insufficient attention to resource issues when developing software for such systems may result in a corresponding software failure after deployment. A real example is the anomaly problem of the Mars Rover Spirit which was due to a memory leakage problem ignored in the software development process. In some cases, such software failure may put human lives at risk. It is thus very important to ensure memory safety and guarantee memory adequacy for software running on these systems.

In this project, we study memory safety and memory usage for programs running on embedded devices, where dynamically allocated objects may be present. Our aims are to verify memory safety for such software, to predict statically (i.e. before a program starts to run) and precisely the memory usage bounds and to ensure that such software will never require more memory than the device can provide.

Memory in software systems are typically organised into two main components: stack and heap. Stack is an efficient way for using and recovering memory spaces, and is important for method invocations and transient objects. Heap is used for more complex data structures that may live beyond the method calls where they are created. Our first objective was accomplished by a multiple-pass analysis which infers automatically memory upper bounds on stack and heap usage for assembly-level programs. The focus on low-level programs was mainly because optimising compilers may render memory analyses done at the source level possibly unsafe to use. The initial experimental results have confirmed the viability of the approach ([ISMM08],[TASE10]).

While the stack bound analysis is generally applicable, the heap bound analysis applies only to programs where mutable objects are not shared. Programs with shared and mutable objects were left into the second objective, for which, we decided to follow a logic-based approach as the originally proposed type-based one ([SAS05],[ICSE05]) is lack of a precise and concise way to specify deep heap properties with must-aliasing and size information. This has proven to be a right move as our new specification language (based on separation logic) allows us to capture precise must-aliasing information for shared mutable objects. It also allows us to capture numerical information (size, memory usage, contents) together with shape information via recursively defined predicates. Our verification system based on this expressive specification mechanism can then automatically verify memory safety (e.g. no dereference to null or dangling pointers), as well as memory usage (i.e. to verify that a program would not require more memory than the device can provide), as shown in our implemented system ([ATVA09],[SCP10]). By conducting automated verification on memory safety and memory usage for programs with shared and mutable objects, we have accomplished the second objective.

Our investigation on the second objective also opened up another challenging research problem: can we automatically compute user-annotations on the shape (incl. aliasing) and size (incl. memory usage) information for programs with shared and mutable objects? This problem is undecidable in general, therefore appropriate abstraction mechanisms would be required. This becomes the main focus of another EPSRC-funded project ( EP-G042322).</gtr:description><gtr:exploitationPathways>The findings can potentially benefit software industry, especially for critical software where memory safety, functional correctness, security etc are of ultimate importance.</gtr:exploitationPathways><gtr:id>A04594FB-6AD4-49EB-969C-4921739F2AB7</gtr:id><gtr:outcomeId>546139aeecfd11.91241577</gtr:outcomeId><gtr:sectors><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software),Healthcare,Security and Diplomacy,Transport</gtr:sector></gtr:sectors><gtr:url>https://www.scm.tees.ac.uk/s.qin/EP-E021948/</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>7B8F9699-8144-443D-BC08-4017A174FB6C</gtr:id><gtr:title>Automated verification of shape, size and bag properties via user-defined predicates in separation logic</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c26fb0b2be2a64af66b54849465e03cf"><gtr:id>c26fb0b2be2a64af66b54849465e03cf</gtr:id><gtr:otherNames>Chin W</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>doi_53d00900944971ee</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>2B74E11E-F81F-4606-AE3A-D40664E2345E</gtr:id><gtr:title>Verifying pointer safety for programs with unknown calls</gtr:title><gtr:parentPublicationTitle>Journal of Symbolic Computation</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/d509230df2ea3b717afda50c35090bd3"><gtr:id>d509230df2ea3b717afda50c35090bd3</gtr:id><gtr:otherNames>Luo C</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2010-01-01</gtr:date><gtr:outcomeId>doi_53cffeffe10569c9</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/E021948/1</gtr:identifier></gtr:identifiers><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>55</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>1E31C833-3A35-4F54-A499-31D0C245B5D5</gtr:id><gtr:percentage>15</gtr:percentage><gtr:text>System on Chip</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>2770EFE0-D127-47F1-9FC0-AABDCE301DD3</gtr:id><gtr:percentage>30</gtr:percentage><gtr:text>VLSI Design</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>