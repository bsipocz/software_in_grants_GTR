<?xml version="1.0" encoding="UTF-8"?>
<gtr:projectOverview xmlns:gtr="http://gtr.ukri.org/api"><gtr:projectComposition><gtr:collaborations/><gtr:leadResearchOrganisation url="http://gtr.ukri.org:80/organisation/B5FF76C6-FFAD-4E1F-9279-7452750B94B7"><gtr:id>B5FF76C6-FFAD-4E1F-9279-7452750B94B7</gtr:id><gtr:name>University of Teesside</gtr:name><gtr:department>Sch of Computing</gtr:department><gtr:address><gtr:line1>Borough Road</gtr:line1><gtr:line4>Middlesbrough</gtr:line4><gtr:line5>Cleveland</gtr:line5><gtr:postCode>TS1 3BA</gtr:postCode><gtr:region>North East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:typeInd>RO</gtr:typeInd></gtr:leadResearchOrganisation><gtr:organisationRoles><gtr:organisationRole url="http://gtr.ukri.org:80/organisation/B5FF76C6-FFAD-4E1F-9279-7452750B94B7"><gtr:id>B5FF76C6-FFAD-4E1F-9279-7452750B94B7</gtr:id><gtr:name>University of Teesside</gtr:name><gtr:address><gtr:line1>Borough Road</gtr:line1><gtr:line4>Middlesbrough</gtr:line4><gtr:line5>Cleveland</gtr:line5><gtr:postCode>TS1 3BA</gtr:postCode><gtr:region>North East</gtr:region><gtr:country>United Kingdom</gtr:country></gtr:address><gtr:roles><gtr:role><gtr:name>LEAD_RO</gtr:name></gtr:role></gtr:roles></gtr:organisationRole></gtr:organisationRoles><gtr:personRoles><gtr:personRole url="http://gtr.ukri.org:80/person/D7F10806-DADF-4898-B707-44150212FE90"><gtr:id>D7F10806-DADF-4898-B707-44150212FE90</gtr:id><gtr:firstName>Shengchao</gtr:firstName><gtr:surname>Qin</gtr:surname><gtr:orcidId>0000-0003-3028-8191</gtr:orcidId><gtr:roles><gtr:role><gtr:name>PRINCIPAL_INVESTIGATOR</gtr:name></gtr:role></gtr:roles></gtr:personRole></gtr:personRoles><gtr:project url="http://gtr.ukri.org:80/projects?ref=EP%2FG042322%2F2"><gtr:id>DA54F032-27DA-43F5-BB38-075CAE762B5F</gtr:id><gtr:title>Inference Mechanisms for a Separation and Numerical Domain</gtr:title><gtr:status>Closed</gtr:status><gtr:grantCategory>Research Grant</gtr:grantCategory><gtr:grantReference>EP/G042322/2</gtr:grantReference><gtr:abstractText>The proliferation of software across all aspects of our life means that software failure can have significant economic and social impact. It is therefore highly desirable to be able to develop software that is formally verified as correct with respect to its expected specification. This has also been identified as a key objective in one of the UK Grand Challenges (GC6). Although research on formal verification has a long history, dating back to the 1960's, it remains a challenging problem to automatically verify programs written in mainstream imperative languages such as C, C++, C# and Java. This is in part due to the prolific use of (recursive) shared mutable data structures which are difficult to keep track of statically and in a precise and concise way.The emergence of separation logic promotes scalable reasoning via explicit separation of structural properties over the memory heap where recursive data structures are dynamically allocated. Using separation logic, progress has recently been made on automated verification for pointer safety in the separation/shape domain. To verify the more general memory safety and functional correctness, it will require the combination of both separation (structural) and numerical (e.g. size) information. Therefore, advanced analysis and verification techniques are needed in the combined separation and numerical domain to verify memory safety and functional correctness. Nevertheless, this remains a clear challenge for program analysis research.As a first step to tackle the challenge, Our recent development on program verification using a combined separation and numerical domain also allows user-specified inductive predicates to appear in program specifications for better expressivity. Based on this specification mechanism, a verification system called HIP/SLEEK has been built to conduct the automated verification and proof search. Our experimental results have confirmed the viability of this approach. One issue with the current system is that it is a liability for the users to supply all loop invariants and method pre/post-conditions prior to the verification. This can be very demanding and challenging for the users.As the second phase towards tackling the challenge, we propose to develop advanced inference mechanisms in the combined separation and numerical domain with user-defined predicates so that loop invariants and method pre/post-conditions can be automatically synthesised, where possible. Achieving this goal means that a much higher level of automation will be achieved, therefore a significant advance will be made in automated verification on memory safety and functional correctness.A key objective in the proposed research is to find a systematic approach to abstraction construction in the combined domain, so that appropriate abstractions can be employed by the inference process. Abstractions are required in the analysis and verification for various reasons, such as termination and scalability. Appropriate abstraction mechanisms are crucial in maintaining a desirable scalability/precision trade-off. Apart from the abstraction mechanisms, we also intend to design analysis algorithms for loop invariant synthesis, method post-condition inference and method pre-condition discovery for the combined domain with arbitrary user-defined predicates. We will build a tool to implement these analyses and apply it to sizeable benchmark programs. As a challenging example, we will apply our tool for the verification of memory safety of a Linux kernel. Such a sizeable program can well be used to test the limit of our inference mechanisms. We believe our research outcomes will further improve the level of automation, and therefore significantly extend the viability and applicability of automated verification on memory safety as well as functional correctness for substantial imperative programs.</gtr:abstractText><gtr:fund><gtr:end>2013-09-30</gtr:end><gtr:funder url="http://gtr.ukri.org:80/organisation/798CB33D-C79E-4578-83F2-72606407192C"><gtr:id>798CB33D-C79E-4578-83F2-72606407192C</gtr:id><gtr:name>EPSRC</gtr:name></gtr:funder><gtr:start>2010-06-01</gtr:start><gtr:type>INCOME_ACTUAL</gtr:type><gtr:valuePounds>332628</gtr:valuePounds></gtr:fund><gtr:output><gtr:artisticAndCreativeProductOutputs/><gtr:collaborationOutputs/><gtr:disseminationOutputs/><gtr:exploitationOutputs/><gtr:furtherFundingOutputs/><gtr:impactSummaryOutputs/><gtr:intellectualPropertyOutputs/><gtr:keyFindingsOutput><gtr:description>The proliferation of software across all aspects of our life means that software failure can have significant economic and social impact. It is therefore highly desirable to be able to develop software that is formally verified as correct with respect to its expected specification. This has also been identified as a key objective in one of the UK Grand Challenges (GC6). Although research on formal verification has a long history, dating back to the 1960's, it remains a challenging problem to automatically verify programs written in mainstream imperative languages such as C, C++, C# and Java. This is in part due to the prolific use of (recursive) shared mutable data structures which are difficult to keep track of statically and in a precise and concise way.

The emergence of separation logic promotes scalable reasoning via explicit separation of structural properties over the memory heap where recursive data structures are dynamically allocated. Using separation logic, progress has been made on automated verification for pointer safety in the separation/shape domain. To verify the more general memory safety and functional correctness, it will require the combination of both separation (structural) and numerical (e.g. size) information. Therefore, advanced analysis and verification techniques are needed in the combined separation and numerical domain to verify memory safety and functional correctness. Nevertheless, this remains a clear challenge for program analysis research.

As a first step to tackle the challenge, Our development on program verification using a combined separation and numerical domain also allows user-specified inductive predicates to appear in program specifications for better expressivity. Based on this specification mechanism, a verification system called HIP/SLEEK has been built by a team led by our collaborator Prof Wei-Ngan Chin to conduct the automated verification and proof search [SCP12,FM11b]. The experimental results have confirmed the viability of this approach. One issue with this system is that it is a liability for the users to supply all loop invariants and method pre/post-conditions prior to the verification. This can be very demanding and challenging for the users.

As the second phase towards tackling the challenge, we propose to develop advanced inference mechanisms in the combined separation and numerical domain with user-defined predicates so that loop invariants and method pre/post-conditions can be automatically synthesised, where possible. Achieving this goal means that a much higher level of automation will be achieved, therefore a significant advance can be made in automated verification on memory safety and functional correctness.

In this project work, we reduce the need of user annotations by automatically inferring loop invariants over an abstract domain with both separation and numerical information [ICFEM10a,JSC13]. Our loop invariant synthesis is conducted automatically by a fixpoint iteration process, equipped with newly designed abstraction mechanism, and join and widening operators. Initial experiments have confirmed that we can synthesise loop invariants with non-trivial constraints.

To tackle the problem of method pre-/post-conditions inference, we have proposed two solutions. In one proposal, we allow users to provide only partial specifications to methods/functions (usually in the form of pre/post shape templates), a lightweight static analysis is then employed to automatically discover missing non-trivial constraints in pre/post to obtain complete pre/post specifications for methods/functions [FM11a,SCP14]. This proposal for refining partial specification is aimed at harnessing the synergy between human's insights and machine's capability at automated program analysis. In particular, human's guidance can help narrow down on the most important of the different specifications that are possible with each program code, while automation by machine is important for minimising on the tedium faced by users. In another proposal [ICFEM13a], we have designed a compositional analysis framework in the presence of user-defined predicates, which derive the pre/post summary for each method in the expressive abstract domain, independently from its callers. We have also proposed a novel abstraction method with a bi-abduction technique in the combined domain to discover pre-/post-conditions that could not be automatically inferred before. The analysis does not only prove the memory safety properties, but also finds relationships between pure and shape domains towards full functional correctness of programs. A prototype of the framework has been implemented and initial experiments have shown that our approach can discover interesting properties for non-trivial programs. In a recent work along this line [CAV14] (which takes place after the project period) we have made a significant step forward by proposing an advanced shape analysis via second-order bi-abduction to automatically discover pre/post shapes for heap-manipulating programs. This recent achievement complements well with either of the two pieces of work mentioned above. In another more recent work [PLDI15], we have applied the bi-aduction idea to help guide case-splits in a unified program analysis for termination and non-termination where specifications corresponding to termination and non-termination can be inferred by the same analysis. 

During this project period, we have also proposed a novel method to verify memory safety of heap-manipulating programs with unknown procedure calls [JSC10,ICFEM10b]. We have conducted a bigger experiment by verifying the FreeRTOS scheduler [TASE12,STTT14b].

In summary, a key objective in the proposed research has been to find a systematic approach to abstraction construction in the combined domain, so that appropriate abstractions can be employed by the inference process. Abstractions are required in the analysis and verification for various reasons, such as termination and scalability. Appropriate abstraction mechanisms are crucial in maintaining a desirable scalability/precision trade-off. Apart from the abstraction mechanisms, we have also designed analysis algorithms for loop invariant synthesis, method post-condition inference and method pre-condition discovery for the combined domain with arbitrary user-defined predicates. We have built prototype tools to implement these analyses and evaluated them on various programs.

Our research outcomes have further improved the level of automation, and therefore significantly extended the viability and applicability of automated verification on memory safety as well as functional correctness for imperative (heap-manipulating) programs.</gtr:description><gtr:exploitationPathways>There are a few aspects for the findings to be taken forward: (1) to rebuild the proposed methods into a proper (not prototype) tool and apply the tool to verify more real code, especially system-level code; (2) to investigate how these inference mechanisms can be extended to the specification and verification of concurrent programs; (3) to investigate how we can extend this line of research to message-passing distributed programs. For (1), we have not had the manpower to rebuild the tool but we have applied the current tool to successfully verify some aspects of the FreeRTOS kernel. We are still focusing more on some open research questions along this line, e.g. decision procedures for satisfiability checking in the combined abstraction domain (for which we have a draft paper), certified reasoning via the integration with Coq. For (2), while we are still in a very early stage to build a verification framework for concurrent programs (including weak memory programs), before we can investigate the analysis/inference mechanisms for such programs, we have made some progress in terms of verification of C11 weak memory programs, we have built a new logic framework (which we called GPS+) on top of the GPS framework in order to reason about fences and relaxed atomics, in addition to release-write/acquire-read atomics. This work has published in PDP16 conference and an extended version has been invited to a journal submission. For (3), we have recently proposed a new session logic in a draft paper, in collaboration with National University of Singapore, that can specify and verify distributed programs with explicit synchronisation and race-free channels.</gtr:exploitationPathways><gtr:id>5F51DB87-1CBF-48E1-B3D3-61BF12B62CDB</gtr:id><gtr:outcomeId>54614e74249b35.13969615</gtr:outcomeId><gtr:sectors><gtr:sector>Aerospace, Defence and Marine,Digital/Communication/Information Technologies (including Software),Energy,Healthcare,Manufacturing, including Industrial Biotechology,Security and Diplomacy,Transport,Other</gtr:sector></gtr:sectors><gtr:url>https://www.scm.tees.ac.uk/s.qin/EP-G042322.html</gtr:url></gtr:keyFindingsOutput><gtr:otherResearchOutputs/><gtr:policyInfluenceOutputs/><gtr:productOutputs/><gtr:researchDatabaseAndModelOutputs/><gtr:researchMaterialOutputs/><gtr:softwareAndTechnicalProductOutputs/><gtr:spinOutOutputs/></gtr:output><gtr:publications><gtr:publication><gtr:id>86EC8DEB-2ADF-41AF-8DC4-3718B3DF16F0</gtr:id><gtr:title>Verifying pointer safety for programs with unknown calls</gtr:title><gtr:parentPublicationTitle>Journal of Symbolic Computation</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/d509230df2ea3b717afda50c35090bd3"><gtr:id>d509230df2ea3b717afda50c35090bd3</gtr:id><gtr:otherNames>Luo C</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2010-01-01</gtr:date><gtr:outcomeId>doi_53cffeffe10569c9</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>2F604B61-81F6-4C0F-A21D-E7EC38389396</gtr:id><gtr:title>Automated specification inference in a combined domain via user-defined predicates</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/b055cfb3d54d8a03276c5e255bd3c26e"><gtr:id>b055cfb3d54d8a03276c5e255bd3c26e</gtr:id><gtr:otherNames>Qin S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2017-01-01</gtr:date><gtr:outcomeId>5a2fe183995fd7.23704409</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>15191241-87EF-4EB2-ABBF-21A32DFEAF2A</gtr:id><gtr:title>Termination and non-termination specification inference</gtr:title><gtr:parentPublicationTitle>ACM SIGPLAN Notices</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/234971086e1080b9c2e8a03abc822bb7"><gtr:id>234971086e1080b9c2e8a03abc822bb7</gtr:id><gtr:otherNames>Le T</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2015-01-01</gtr:date><gtr:outcomeId>56c45ab3962c75.71954980</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>59E2A2ED-3B27-4BA7-8989-3C634D3A2CAE</gtr:id><gtr:title>Expressive program verification via structured specifications</gtr:title><gtr:parentPublicationTitle>International Journal on Software Tools for Technology Transfer</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/955b00362078f217a3a29ab97e790559"><gtr:id>955b00362078f217a3a29ab97e790559</gtr:id><gtr:otherNames>Gherghina C</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>56c45b58ce2688.37641850</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>22A9ACD2-DC32-4C78-8AA3-46BA3BCD38F2</gtr:id><gtr:title>Automated verification of shape, size and bag properties via user-defined predicates in separation logic</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/c26fb0b2be2a64af66b54849465e03cf"><gtr:id>c26fb0b2be2a64af66b54849465e03cf</gtr:id><gtr:otherNames>Chin W</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2012-01-01</gtr:date><gtr:outcomeId>doi_53d00900944971ee</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>C65922AF-836A-4CB5-B2BF-48D8F178C08C</gtr:id><gtr:title>Reasoning about Fences and Relaxed Atomics</gtr:title><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/3056b899bd6dafc64c0b2150e4f403d5"><gtr:id>3056b899bd6dafc64c0b2150e4f403d5</gtr:id><gtr:otherNames>He M</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2016-01-01</gtr:date><gtr:outcomeId>58b832960ecca3.87535019</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>64BF9CA5-BB08-4831-BB46-98C6BE2CFC54</gtr:id><gtr:title>Automated verification of the FreeRTOS scheduler in Hip/Sleek</gtr:title><gtr:parentPublicationTitle>International Journal on Software Tools for Technology Transfer</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/8722a5f56270e175ee1d9072f5dea03c"><gtr:id>8722a5f56270e175ee1d9072f5dea03c</gtr:id><gtr:otherNames>Ferreira J</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>56c45b59062f40.45341200</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>A33A0C32-B0C3-465B-A1E8-AD6356544226</gtr:id><gtr:title>Automatically refining partial specifications for heap-manipulating programs</gtr:title><gtr:parentPublicationTitle>Science of Computer Programming</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/b055cfb3d54d8a03276c5e255bd3c26e"><gtr:id>b055cfb3d54d8a03276c5e255bd3c26e</gtr:id><gtr:otherNames>Qin S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2014-01-01</gtr:date><gtr:outcomeId>doi_53d0090094ed15dd</gtr:outcomeId></gtr:publication><gtr:publication><gtr:id>3B8E8297-FA0E-4A41-AF97-3096BDAEE134</gtr:id><gtr:title>Loop invariant synthesis in a combined abstract domain</gtr:title><gtr:parentPublicationTitle>Journal of Symbolic Computation</gtr:parentPublicationTitle><gtr:authors><gtr:author url="http://gtr.ukri.org:80/person/b055cfb3d54d8a03276c5e255bd3c26e"><gtr:id>b055cfb3d54d8a03276c5e255bd3c26e</gtr:id><gtr:otherNames>Qin S</gtr:otherNames></gtr:author></gtr:authors><gtr:date>2013-01-01</gtr:date><gtr:outcomeId>doi_53cffeffe152aaea</gtr:outcomeId></gtr:publication></gtr:publications><gtr:identifiers><gtr:identifier type="RCUK">EP/G042322/2</gtr:identifier></gtr:identifiers><gtr:projectHierarchy><gtr:parents><gtr:parent><gtr:id>E417AD16-2322-481B-9B5C-60582522386D</gtr:id><gtr:grantRef>EP/G042322/1</gtr:grantRef><gtr:amount>395661.9</gtr:amount><gtr:start>2009-10-01</gtr:start><gtr:end>2010-05-31</gtr:end><gtr:children><gtr:child rel="Transfer"><gtr:id>DA54F032-27DA-43F5-BB38-075CAE762B5F</gtr:id><gtr:grantRef>EP/G042322/2</gtr:grantRef><gtr:amount>332628.53</gtr:amount><gtr:start>2010-06-01</gtr:start><gtr:end>2013-09-30</gtr:end><gtr:children/></gtr:child></gtr:children></gtr:parent></gtr:parents></gtr:projectHierarchy><gtr:healthCategories/><gtr:researchActivities/><gtr:researchSubjects><gtr:researchSubject><gtr:id>EB5F16BB-2772-4DDE-BD6C-3B7A6914B64C</gtr:id><gtr:percentage>100</gtr:percentage><gtr:text>Info. &amp; commun. Technol.</gtr:text></gtr:researchSubject></gtr:researchSubjects><gtr:researchTopics><gtr:researchTopic><gtr:id>76783275-A9F8-4B4E-B314-51363124259C</gtr:id><gtr:percentage>25</gtr:percentage><gtr:text>Fundamentals of Computing</gtr:text></gtr:researchTopic><gtr:researchTopic><gtr:id>E05CFE0B-163D-412D-A3C2-28E89B2CA336</gtr:id><gtr:percentage>75</gtr:percentage><gtr:text>Software Engineering</gtr:text></gtr:researchTopic></gtr:researchTopics><gtr:rcukProgrammes/></gtr:project></gtr:projectComposition></gtr:projectOverview>